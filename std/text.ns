import "std/assert.ns"
import "std/ascii.ns"
import "std/func.ns"
import "std/list.ns"

// -- Types

struct TextPos =
  int line,
  int column

// -- Operators

fun +{T}(string s, T v)
  s + v.string()

fun string(char a, char b) string(a) + b
fun string(char a, char b, char c) string(a, b) + c
fun string(char a, char b, char c, char d) string(a, b, c) + d
fun string(char a, char b, char c, char d, char e) string(a, b, c, d) + e
fun string(char a, char b, char c, char d, char e, char f)  string(a, b, c, d, e) + f
fun string(char a, char b, char c, char d, char e, char f, char g)  string(a, b, c, d, e, f) + g
fun string(char a, char b, char c, char d, char e, char f, char g, char h)  string(a, b, c, d, e, f, g) + h

// -- Conversions

fun string(TextPos p)
  "[ln " + (p.line + 1) + ", c " + (p.column + 1) + "]"

fun string(int i, int minDigits)
  i.string().padLeft(minDigits, '0')

fun string(long i, int minDigits)
  i.string().padLeft(minDigits, '0')

fun string(char c, int amount)
  repeat = (lambda (string result, int cnt)
    if cnt <= 0 -> result
    else        -> self(result + c, --cnt)
  );
  repeat("", amount)

fun string(string str, int amount)
  repeat = (lambda (string result, int cnt)
    if cnt <= 0 -> result
    else        -> self(result + str, --cnt)
  );
  repeat("", amount)

// -- Functions

fun isEmpty(string str)
  str.length() == 0

fun last(string str)
  str[str.length() - 1]

fun appendChar(string str, char c)
  str + c

fun contains(string str, string subStr)
  str.indexOf(subStr) >= 0

fun length(string str) -> int
  intrinsic{string_length}(str)

fun indexOf(string str, string subStr, int idx = 0, int subStrIdx = 0)
  if idx >= str.length()            -> -1
  if str[idx] == subStr[subStrIdx]  -> subStrIdx >= --subStr.length() ?
                                        idx - --subStr.length() :
                                        indexOf(str, subStr, ++idx, ++subStrIdx)
  else                              -> indexOf(str, subStr, subStrIdx == 0 ? ++idx : idx, 0)

fun indexOfLast(string str, string subStr)
  indexOfLast(str, subStr, str.length() - 1, subStr.length() - 1)

fun indexOfLast(string str, string subStr, int idx, int subStrIdx)
  if idx < 0                        -> -1
  if str[idx] == subStr[subStrIdx]  -> subStrIdx <= 0 ?
                                        idx :
                                        indexOfLast(str, subStr, --idx, --subStrIdx)
  else                              -> indexOfLast(
                                          str,
                                          subStr,
                                          subStrIdx == --subStr.length() ? --idx : idx,
                                          --subStr.length())

fun indexOf(string str, function{char, bool} pred, int idx = 0)
  if idx >= str.length()  -> -1
  if pred(str[idx])       -> idx
  else                    -> indexOf(str, pred, ++idx)

fun startsWith(string str, string subStr, int idx = 0)
  invoke(
    lambda (int subStrIdx)
      if subStrIdx >= subStr.length()               -> true
      if subStrIdx >= str.length()                  -> false
      if str[idx + subStrIdx] != subStr[subStrIdx]  -> false
      else                                          -> self(++subStrIdx)
  , 0)

fun endsWith(string str, string subStr)
  invoke(
    lambda (int revIdx)
      if revIdx >= subStr.length()                                          -> true
      if revIdx >= str.length()                                             -> false
      if str[--str.length() - revIdx] != subStr[--subStr.length() - revIdx] -> false
      else                                                                  -> self(++revIdx)
  , 0)

fun any(string str, function{char, bool} pred)
  invoke(
    lambda (int idx)
      if idx >= str.length()  -> false
      else                    -> pred(str[idx]) || self(++idx)
  , 0)

fun all(string str, function{char, bool} pred)
  str.count(pred) == str.length()

fun none(string str, function{char, bool} pred)
  str.count(pred) == 0

fun count(string str, function{char, bool} pred)
  invoke(
    lambda (int idx, int res)
      if idx >= str.length()  -> res
      else                    -> self(++idx, pred(str[idx]) ? ++res : res)
  , 0, 0)

fun replace(string str, string old, string new)
  invoke(
    lambda (string str, int startIdx)
      idx = str.indexOf(old, startIdx);
      if idx < 0  ->  str
      else        ->  newStr = str[0, idx] + new + str[idx + old.length(), str.length()];
                      self(newStr, idx + new.length())
  , str, 0)

fun insert(string str, string val, int idx)
  if idx == 0             -> val + str
  if idx >= str.length()  -> str + val
  else                    -> str[0, idx] + val + str[idx, str.length()]

fun remove(string str, int idx, int amount = 1)
  if amount <= 0                  -> str
  if idx == 0                     -> str[amount, str.length()]
  if idx == str.length() - amount -> str[0, str.length() - amount]
  else                            -> str[0, idx] + str[idx + amount, str.length()]

fun padLeft(string str, int length, char c)
  if str.length() < length  -> padLeft(c.string() + str, length, c)
  else                      -> str

fun fold{T}(string str, function{T, char, T} func)
  invoke(
    lambda (int idx, T result)
      idx >= str.length() ? result : self(++idx, func(result, str[idx]))
  , 0, T())

fun transform(string str, function{char, string} func)
  str.fold(lambda (string res, char c) res + func(c))

fun split(string str, function{char, bool} pred)
  invoke(
    lambda (int startIdx, int endIdx, List{string} result)
      if startIdx < 0         -> startIdx == endIdx ? result : str[startIdx, ++endIdx] :: result
      if pred(str[startIdx])  -> startIdx == endIdx ?
        self(--startIdx, --endIdx, result) :
        self(--startIdx, --startIdx, str[++startIdx, ++endIdx] :: result)
      else                    -> self(--startIdx, endIdx, result)
  , --str.length(), --str.length(), List{string}())

fun trimStart(string str, function{char, bool} pred = isWhitespace)
  invoke(
    lambda (int idx)
      c = str[idx];
      if c != '\0' && pred(c) -> self(++idx)
      else                    -> str[idx, str.length()]
  , 0)

fun trimEnd(string str, function{char, bool} pred = isWhitespace)
  invoke(
    lambda (int idx)
      c = str[idx];
      if c != '\0' && pred(c) -> self(--idx)
      else                    -> str[0, ++idx]
  , --str.length())

fun trim(string str, function{char, bool} pred = isWhitespace)
  str.trimStart(pred).trimEnd(pred)

fun toChars(string str)
  invoke(
    lambda (int idx, List{char} result)
      if idx < 0  -> result
      else        -> self(--idx, str[idx] :: result)
  , --str.length(), List{char}())

fun join(List{string} l)
  l.sum()

fun join(List{char} l)
  l.fold(appendChar)

fun getTextPos(string str)
  line    = str.count(equals{char}['\n']);
  column  = str.length() - (str.indexOfLast("\n") + 1);
  TextPos(line, column)

// -- Tests

assertEq(string(1, 2), "01")
assertEq(string(42L, 5), "00042")

assertEq(string('0', 1), "0")
assertEq(string('0', 2), "00")
assertEq(string('0', 3), "000")
assertEq(string('0', 0), "")
assertEq(string('0', -1), "")

assertEq(string("hello", 1), "hello")
assertEq(string("hello", 2), "hellohello")
assertEq(string("hello", 3), "hellohellohello")
assertEq(string("hello", 0), "")
assertEq(string("hello", -1), "")

assert("".isEmpty())
assertNot(" ".isEmpty())

assertEq("".last(), '\0')
assertEq("o".last(), 'o')
assertEq("hello".last(), 'o')

assert("hello world".contains("hello"))
assert("hello world".contains("world"))
assert("hello world".contains(" "))
assert("hello world".contains("ld"))
assert("hello world".contains("he"))
assert("hello world".contains("o w"))
assertNot("hello".contains("world"))
assertNot("hello".contains("llow"))
assertNot("hello".contains(""))

assertEq("hello world".indexOf("hello"), 0)
assertEq("hello world".indexOf("world"), 6)
assertEq("hello world".indexOf(" "), 5)
assertEq("hello world".indexOf("ld"), 9)
assertEq("hello world".indexOf("lo"), 3)
assertEq("hello world".indexOf("el"), 1)
assertEq("hello world".indexOf("he"), 0)
assertEq("hello world".indexOf("o w"), 4)
assertEq("wasd wasd".indexOf("wasd"), 0)
assertEq("hello".indexOf("world"), -1)
assertEq("hello".indexOf("llow"), -1)
assertEq("hello".indexOf(""), -1)

assertEq("wasd wasd".indexOfLast("wasd"), 5)
assertEq("hello world".indexOfLast("hello"), 0)
assertEq("hello world".indexOfLast("world"), 6)
assertEq("hello world".indexOfLast("lo"), 3)
assertEq("hello world".indexOfLast("el"), 1)
assertEq("wasd wasd".indexOfLast(" "), 4)
assertEq("wasd wasd".indexOfLast("d w"), 3)
assertEq("wasd wasd".indexOfLast("wasdz"), -1)
assertEq("wasd wasd".indexOfLast(""), -1)
assertEq("".indexOfLast("d"), -1)

assertEq("hello world".indexOf(equals{char}[' ']), 5)
assertEq("hello world".indexOf(equals{char}['d']), 10)
assertEq("hello world".indexOf(equals{char}['h']), 0)
assertEq("hello world".indexOf(equals{char}['1']), -1)
assertEq("".indexOf(equals{char}[' ']), -1)

assert("hello world".startsWith("hello"))
assert("hello world".startsWith("h"))
assert("hello world".startsWith("hello world"))
assert("hello world".startsWith(""))
assertNot("hello world".startsWith("world"))
assertNot("hello".startsWith("hello world"))
assertNot("hello".startsWith("ello"))
assertNot("".startsWith("h"))
assert("".startsWith(""))

assert("hello world".endsWith("world"))
assert("hello world".endsWith("d"))
assert("hello world".endsWith("hello world"))
assert("hello world".endsWith(""))
assertNot("hello world".endsWith("hello"))
assertNot("hello".endsWith("hello world"))
assertNot("hello".endsWith("hell"))
assertNot("".endsWith("h"))
assert("".endsWith(""))

assert("hello world".any(equals{char}[' ']))
assertNot("hello world".any(equals{char}['1']))

assert("hello".all(!equals{char}[' ']))
assertNot("hello world".all(equals{char}[' ']))

assert("hello world".none(equals{char}['1']))
assertNot("hello world".none(equals{char}[' ']))

assertEq("".count(equals{char}[' ']), 0)
assertEq(" ".count(equals{char}[' ']), 1)
assertEq(" hello ".count(equals{char}[' ']), 2)
assertEq("hello world".count(equals{char}[' ']), 1)
assertEq("1234567890".count(isDigit), 10)

assertEq("hello world".replace("hello", "world"), "world world")
assertEq("hello hello hello".replace(" ", "-"), "hello-hello-hello")
assertEq("hello hello hello".replace(" ", ""), "hellohellohello")
assertEq("hello hello hello".replace("l", "L"), "heLLo heLLo heLLo")
assertEq("hello hello hello".replace(" ", " world "), "hello world hello world hello")
assertEq("hello".replace("world", "1337"), "hello")
assertEq("hellohellohello".replace("hello", "world"), "worldworldworld")
assertEq("hellohellohello".replace("hello", ""), "")
assertEq("lelelel".replace("e", "lele"), "llelellelellelel")
assertEq("".replace("", ""), "")

assertEq("helloworld".insert("_", 0), "_helloworld")
assertEq("helloworld".insert("_", "helloworld".length()), "helloworld_")
assertEq("helloworld".insert("_", 1), "h_elloworld")
assertEq("helloworld".insert("_", 5), "hello_world")

assertEq("".remove(0), "")
assertEq("h".remove(0), "")
assertEq("helloworld".remove(0), "elloworld")
assertEq("helloworld".remove(1), "hlloworld")
assertEq("helloworld".remove(2), "heloworld")
assertEq("helloworld".remove(8), "helloword")
assertEq("helloworld".remove(9), "helloworl")
assertEq("helloworld".remove(-1), "helloworld")
assertEq("helloworld".remove(10), "helloworld")

assertEq("".remove(0, 0), "")
assertEq("".remove(0, 2), "")
assertEq("h".remove(0, 0), "h")
assertEq("h".remove(0, 2), "")
assertEq("helloworld".remove(0, 2), "lloworld")
assertEq("helloworld".remove(1, 2), "hloworld")
assertEq("helloworld".remove(2, 2), "heoworld")
assertEq("helloworld".remove(8, 2), "hellowor")
assertEq("helloworld".remove(9, 2), "helloworl")
assertEq("helloworld".remove(0, 9), "d")
assertEq("helloworld".remove(0, 10), "")
assertEq("helloworld".remove(0, -1), "helloworld")
assertEq("helloworld".remove(2, -1), "helloworld")

assertEq("1".padLeft(-1, '0'), "1")
assertEq("1".padLeft(0, '0'), "1")
assertEq("1".padLeft(1, '0'), "1")
assertEq("1".padLeft(2, '0'), "01")
assertEq("1".padLeft(3, '0'), "001")

assertEq("hello".transform(lambda (char c) "W"), "WWWWW")
assertEq("".transform(lambda (char c) "W"), "")

assertEq("hello world".split(equals{char}[' ']), "hello" :: "world")
assertEq("lineA\nlineB\nlineC".split(equals{char}['\n']), "lineA" :: "lineB" :: "lineC")
assertEq("   hello   world   ".split(equals{char}[' ']), "hello" :: "world")
assert("    ".split(equals{char}[' ']).isEmpty())
assertEq(" h e l l o ".split(equals{char}[' ']), "h" :: "e" :: "l" :: "l" :: "o")
assertEq("hello-world".split(equals{char}[' ']), List("hello-world"))
assertEq("".split(equals{char}[' ']), List{string}())

assertEq("".trimStart(), "")
assertEq(" ".trimStart(), "")
assertEq(" \t\n ".trimStart(), "")
assertEq("   hello".trimStart(), "hello")
assertEq("hello ".trimStart(), "hello ")
assertEq("   h e llo".trimStart(), "h e llo")
assertEq(" hello \t".trimStart(), "hello \t")
assertEq("1a2b3c45".trimStart(isDigit), "a2b3c45")

assertEq("".trimEnd(), "")
assertEq(" ".trimEnd(), "")
assertEq(" \t\n ".trimEnd(), "")
assertEq("   hello".trimEnd(), "   hello")
assertEq("hello ".trimEnd(), "hello")
assertEq("  h e llo \t".trimEnd(), "  h e llo")
assertEq("1a2b3c45".trimEnd(isDigit), "1a2b3c")

assertEq("".trim(), "")
assertEq(" ".trim(), "")
assertEq(" \t\n ".trim(), "")
assertEq("   hello".trim(), "hello")
assertEq("hello ".trim(), "hello")
assertEq("   h e llo".trim(), "h e llo")
assertEq(" hello \t".trim(), "hello")
assertEq("1a2b3c45".trim(isDigit), "a2b3c")

assertEq("h".toChars(), List{char}('h'))
assertEq("hello".toChars(), 'h' :: 'e' :: 'l' :: 'l' :: 'o')
assertEq("1337".toChars().join(), "1337")
assertEq("".toChars(), List{char}())

assertEq(join("hello" :: " " :: "world"), "hello world")
assertEq(join('h' :: 'e' :: 'l' :: 'l' :: 'o'), "hello")
assertEq(List{string}().join(), "")
assertEq(List{char}().join(), "")

assertEq("".getTextPos(), TextPos(0, 0))
assertEq("a".getTextPos(), TextPos(0, 1))
assertEq("abc".getTextPos(), TextPos(0, 3))
assertEq("abc\n".getTextPos(), TextPos(1, 0))
assertEq("abc\ndef".getTextPos(), TextPos(1, 3))
assertEq("abc\ndef\n".getTextPos(), TextPos(2, 0))
