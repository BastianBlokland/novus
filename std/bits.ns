import "std/parser.ns"
import "std/text.ns"
import "std/type.ns"
import "std/writer.ns"

// -- Types

enum Endianness =
  Little  : 0,
  Big     : 1

// -- Conversions

fun string(Endianness e)
  if e == Endianness.Little -> "LittleEndian"
  if e == Endianness.Big    -> "BigEndian"
  else                      -> "Unknown"

// -- Utilities

// Unset the least significant set bit.
fun unsetLow{T}(T mask) -> T
  mask & mask - T(1)

// Clears all but the least significant set bit.
fun onlyLow{T}(T mask) -> T
  mask & ~mask + T(1)

fun onlyHigh{T}(T mask) -> T
  T(1) << (bitSize{T}() - leadingZeroes(mask) - 1)

// Unset the most significant set bit.
fun unsetHigh{T}(T mask) -> T
  msb = T(1) << (bitSize{T}() - leadingZeroes(mask) - 1);
  mask & ~msb

// Count how many bits are set.
fun popCount{T}(T mask) -> int
  f = ( lambda (T mask, int num)
    if mask == 0  -> num
    else          -> self(unsetLow(mask), ++num)
  ); f(mask, 0)

// Count the trailing zeroes.
fun trailingZeroes{T}(T mask) -> int
  if mask == 0  -> bitSize{T}()
  else          ->
    f = ( lambda (T mask, int num)
      if mask == 0 || (mask & 1) != 0 -> num
      else                            -> self(mask >> 1, ++num)
    ); f(mask, 0)

// Count the leading zeroes.
fun leadingZeroes{T}(T mask) -> int
  if mask == 0  -> bitSize{T}()
  else          ->
    f = ( lambda (T mask, int num)
      if (mask & highBit{T}()) != 0 -> num
      else                          -> self(mask << 1, ++num)
    ); f(mask, 0)

// Returns a new mask with only the Nth least significant set bit still set.
// Examples:
// * Mask 10010100 bit 0 = 00000100
// * Mask 10010100 bit 1 = 00010000
// * Mask 10010100 bit 2 = 10000000
fun nthSetBit{T}(T mask, int bit) -> T
  f = (lambda (T mask, int i)
    if i >= bit -> onlyLow(mask)
    else        -> self(unsetLow(mask), ++i)
  ); f(mask, 0)

// Convert the mask into a binary string with characters '0' and '1'.
fun toBitString{T}(T mask, bool includeLeadingZeroes = false) -> string
  if mask == 0 -> string('0', includeLeadingZeroes ? bitSize{T}() : 1)
  else         ->
    f = ( lambda (int idx, string result)
      if idx < 0  -> result
      else        -> self(--idx, result + ((mask & T(1) << idx) == 0 ? '0' : '1'))
    ); f(bitSize{T}() - (includeLeadingZeroes ? 1 : leadingZeroes(mask) + 1), "")

// Convert the mask into a hexadecimal string with characters '0'-'9' and 'A'-'F'.
fun toHexString{T}(T mask, bool includeLeadingZeroes = false) -> string
  if mask == 0  -> string('0', includeLeadingZeroes ? nibbleSize{T}() : 1)
  else          ->
    f = ( lambda (T mask, string result)
      if mask == 0  -> result
      else          -> self(
        mask >> 4,
        v = mask & T(0xF);
        string(v < 10 ? char('0' + v) : char('A' + v - 10)) + result)
    ); string('0', includeLeadingZeroes ? (leadingZeroes(mask) / 4) : 0) + f(mask, "")

fun signExtend16To32(int val) -> int
  (0xffff & val ^ 0x8000) - 0x8000

fun parseInt16(Endianness en, char a, char b) -> int
  if en == Endianness.Little -> (int(a) << 0) | (int(b) << 8)
  else                       -> (int(a) << 8) | (int(b) << 0)

fun parseSInt16(Endianness en, char a, char b) -> int
  if en == Endianness.Little -> signExtend16To32((int(a) << 0) | (int(b) << 8))
  else                       -> signExtend16To32((int(a) << 8) | (int(b) << 0))

fun parseInt32(Endianness en, char a, char b, char c, char d) -> int
  if en == Endianness.Little -> (int(a) << 0)  | (int(b) << 8)  | (int(c) << 16) | (int(d) << 24)
  else                       -> (int(a) << 24) | (int(b) << 16) | (int(c) << 8)  | (int(d) << 0)

fun parseInt64(Endianness en, char a, char b, char c, char d, char e, char f, char g, char h) -> long
  if en == Endianness.Little ->
    (long(a) << 0)  | (long(b) << 8)  | (long(c) << 16) | (long(d) << 24) |
    (long(e) << 32) | (long(f) << 40) | (long(g) << 48) | (long(h) << 56)
  else                       ->
    (long(a) << 56) | (long(b) << 48) | (long(c) << 40) | (long(d) << 32) |
    (long(e) << 24) | (long(f) << 16) | (long(g) << 8)  | (long(h) << 0)

// -- Parsers

fun bitInt8Parser() -> Parser{char}
  charParser()

fun bitInt16Parser(Endianness e) -> Parser{int}
  takeParser(2).map(lambda (string s) parseInt16(e, s[0], s[1]))

fun bitSInt16Parser(Endianness e) -> Parser{int}
  takeParser(2).map(lambda (string s) parseSInt16(e, s[0], s[1]))

fun bitInt32Parser(Endianness e) -> Parser{int}
  takeParser(4).map(lambda (string s) parseInt32(e, s[0], s[1], s[2], s[3]))

fun bitInt64Parser(Endianness e) -> Parser{long}
  takeParser(8).map(lambda (string s) parseInt64(e, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]))

// -- Writers

fun bitInt8Writer() -> Writer{char}
  charWriter()

fun bitInt16Writer(Endianness e) -> Writer{int}
  e == Endianness.Little
    ? Writer(lambda (WriterState s, int i)
        s.write(char(i >> 0))
         .write(char(i >> 8)))
    : Writer(lambda (WriterState s, int i)
        s.write(char(i >> 8))
         .write(char(i >> 0)))

fun bitInt32Writer(Endianness e) -> Writer{int}
  e == Endianness.Little
    ? Writer(lambda (WriterState s, int i)
        s.write(char(i >> 0))
         .write(char(i >> 8))
         .write(char(i >> 16))
         .write(char(i >> 24)))
    : Writer(lambda (WriterState s, int i)
        s.write(char(i >> 24))
         .write(char(i >> 16))
         .write(char(i >> 8))
         .write(char(i >> 0)))

fun bitInt64Writer(Endianness e) -> Writer{long}
  e == Endianness.Little
    ? Writer(lambda (WriterState s, long l)
        s.write(char(l >> 0))
         .write(char(l >> 8))
         .write(char(l >> 16))
         .write(char(l >> 24))
         .write(char(l >> 32))
         .write(char(l >> 40))
         .write(char(l >> 48))
         .write(char(l >> 56)))
    : Writer(lambda (WriterState s, long l)
        s.write(char(l >> 56))
         .write(char(l >> 48))
         .write(char(l >> 40))
         .write(char(l >> 32))
         .write(char(l >> 24))
         .write(char(l >> 16))
         .write(char(l >> 8))
         .write(char(l >> 0)))

// -- Actions

act endiannessNative() Endianness(intrinsic{platform_endianness_native}())

// -- Tests

assert(
  unsetLow(0b111) == 0b110 &&
  unsetLow(0b110) == 0b100 &&
  unsetLow(0b11000000) == 0b10000000 &&
  unsetLow(0) == 0 &&
  unsetLow(1) == 0)

assert(
  unsetLow(char(0b111)) == 0b110 &&
  unsetLow(char(0b110)) == 0b100 &&
  unsetLow(char(0b11000000)) == 0b10000000)

assert(
  unsetLow(0xFFFF_FFFF_FFFF0L) == 0xFFFF_FFFF_FFFE0L &&
  unsetLow(0xFFFF_FFFF_FFFFL) == 0xFFFF_FFFF_FFFEL)

assert(
  onlyLow(0) == 0 &&
  onlyLow(1) == 1 &&
  onlyLow(-1) == 1 &&
  onlyLow(0b100) == 0b100 &&
  onlyLow(0b1010_1000) == 0b1000)

assert(
  onlyLow(char(0xFF)) == char(1) &&
  onlyLow(char(0b100)) == char(0b100) &&
  onlyLow(char(0b1010_1000)) == char(0b1000))

assert(
  onlyLow(0xFFFF_FFFF_FFFF0L) == 0x10L &&
  onlyLow(0xFFFF_FFFF_FFFFL) == 0x1L)

assert(
  unsetHigh(0) == 0 &&
  unsetHigh(1) == 0 &&
  unsetHigh(0b11) == 0b1 &&
  unsetHigh(0b1101) == 0b101 &&
  unsetHigh(0b1101001) == 0b101001 &&
  unsetHigh(0b1001101001) == 0b1101001 &&
  unsetHigh(-1) == -1 >> 1 &&
  unsetHigh(0b1000_0000_0000_0000_0000_0000_0100_1000) == 0b100_1000)

assert(
  unsetHigh(char(0b11)) == char(0b1) &&
  unsetHigh(char(0b1101)) == char(0b101) &&
  unsetHigh(char(0b1101001)) == char(0b101001))

assert(
  unsetHigh(0xFFFF_FFFF_FFFFL) == 0x7FFF_FFFF_FFFFL &&
  unsetHigh(0xFFFF_FFFF_FFFF_FFFFL) == 0x7FFF_FFFF_FFFF_FFFFL)

assert(
  popCount(0) == 0 &&
  popCount(1) == 1 &&
  popCount(0b0010) == 1 &&
  popCount(0b101) == 2 &&
  popCount(0b100101) == 3 &&
  popCount(0xFFFF_FFFF) == 32 &&
  popCount(0xEFFF_FFFF) == 31)

assert(
  popCount(char(0b100101)) == 3 &&
  popCount(char(0xFF)) == 8)

assert(
  popCount(0xFFFF_F0FF_FFFFL) == 44 &&
  popCount(0xFFFF_FFFF_FFFFL) == 48 &&
  popCount(0xFFFF_FFFF_FFFF_FFFFL) == 64)

assert(
  trailingZeroes(0) == 32 &&
  trailingZeroes(-1) == 0 &&
  trailingZeroes(0b10) == 1 &&
  trailingZeroes(0b10100) == 2 &&
  trailingZeroes(0b101001000) == 3)

assert(
  trailingZeroes(char(0b100100)) == 2 &&
  trailingZeroes(char(0xFF)) == 0 &&
  trailingZeroes(char(0)) == 8)

assert(
  trailingZeroes(0xFFFF_FFFF_FFFF_FFFFL) == 0 &&
  trailingZeroes(0xFFFF_0000L) == 16 &&
  trailingZeroes(0x1000_0000_0000_0000L) == 60 &&
  trailingZeroes(0L) == 64)

assert(
  leadingZeroes(0) == 32 &&
  leadingZeroes(-1) == 0 &&
  leadingZeroes(1) == 31 &&
  leadingZeroes(1 << 30) == 1 &&
  leadingZeroes(1 << 15) == 16 &&
  leadingZeroes(0b0000_0100_0101_0101_0110_0101_0100_1000) == 5 &&
  leadingZeroes(-1) == 0)

assert(
  leadingZeroes(char(0)) == 8 &&
  leadingZeroes(char(0b1)) == 7 &&
  leadingZeroes(char(0xFF)) == 0)

assert(
  leadingZeroes(0xFFFF_FFFF_FFFF_FFFFL) == 0 &&
  leadingZeroes(0xF0F0_F0F0L) == 32 &&
  leadingZeroes(0x1000_0000_0000_0000L) == 3 &&
  leadingZeroes(0L) == 64)

assert(
  nthSetBit(0, -1) == 0 &&
  nthSetBit(0, 0) == 0 &&
  nthSetBit(0, 1) == 0 &&
  nthSetBit(0b1, 0) == 1 &&
  nthSetBit(0b1, 1) == 0 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 2) == 0b1000 &&
  nthSetBit(0b1001_1101, 4) == 0b1000_0000)

assert(
  nthSetBit(char(0b1), 0)   == 1 &&
  nthSetBit(char(0b1001_1101), 0) == 1 &&
  nthSetBit(char(0b1001_1101), 2) == 0b1000 &&
  nthSetBit(char(0b1001_1101), 4) == 0b1000_0000)

assert(
  nthSetBit(0b1L, 0)   == 1 &&
  nthSetBit(0b1001_1101L, 0) == 1 &&
  nthSetBit(0xFFFF_FFFF_FFFF_FFFFL, 0) == 1 &&
  nthSetBit(0xFFFF_FFFF_FFFF_1010L, 1) == 0x1000L)

assert(
  toBitString(0) == "0" &&
  toBitString(0, true) == string('0', 32) &&
  toBitString(-1) == string('1', 32) &&
  toBitString(-1, true) == string('1', 32) &&
  toBitString(1) == "1" &&
  toBitString(2) == "10" &&
  toBitString(4) == "100" &&
  toBitString(0b1011_1101_1111) == "101111011111" &&
  toBitString(0b0000_0100_0101_0101_0110_0101_0100_1000, true) == "00000100010101010110010101001000")

assert(
  toBitString(char(0)) == "0" &&
  toBitString(char(0), true) == string('0', 8) &&
  toBitString(char(0b0101_0101), true) == "01010101")

assert(
  toBitString(0L) == "0" &&
  toBitString(0L, true) == string('0', 64) &&
  toBitString(~0L) == string('1', 64))

assert(
  toHexString(0) == "0" &&
  toHexString(-1) == "FFFFFFFF" &&
  toHexString(1) == "1" &&
  toHexString(0x1A2B3C) == "1A2B3C" &&
  toHexString(0xABCDEF) == "ABCDEF" &&
  toHexString(0x123ABC) == "123ABC")

assert(
  toHexString(0, true) == "00000000" &&
  toHexString(-1, true) == "FFFFFFFF" &&
  toHexString(1, true) == "00000001" &&
  toHexString(0x0ABCDEF0, true) == "0ABCDEF0")

assert(
  toHexString(char(0)) == "0" &&
  toHexString(char(0xE)) == "E" &&
  toHexString(char(0xFA)) == "FA")

assert(
  toHexString(char(0), true) == "00" &&
  toHexString(char(0xE), true) == "0E" &&
  toHexString(char(0xFA), true) == "FA")

assert(
  toHexString(0L) == "0" &&
  toHexString(0xFFFF_FFFF_FFFFL) == "FFFFFFFFFFFF" &&
  toHexString(0x1234_ABCD_EF99L) == "1234ABCDEF99")

assert(
  toHexString(0L, true) == "0000000000000000" &&
  toHexString(~0L, true) == "FFFFFFFFFFFFFFFF" &&
  toHexString(0x00AB_CDEF_1234_FFFFL, true) == "00ABCDEF1234FFFF")

assert(bitInt8Writer()('a') == "a")

assert(
  w = bitInt8Writer();
  p = bitInt8Parser();
  p(w(char(0)).string())    == char(0)    &&
  p(w(char(1)).string())    == char(1)    &&
  p(w(char(-1)).string())   == char(-1)   &&
  p(w(char(42)).string())   == char(42)   &&
  p(w(char(-42)).string())  == char(-42)  &&
  p(w(char(240)).string())  == char(240)  &&
  p(w(char(256)).string())  == char(256))

assert(
  w = bitInt16Writer(Endianness.Little);
  p = bitSInt16Parser(Endianness.Little);
  w(1337)                 == string(char(57), char(5))  &&
  p(w(0).string())        == 0                          &&
  p(w(1).string())        == 1                          &&
  p(w(-1).string())       == -1                         &&
  p(w(42).string())       == 42                         &&
  p(w(-42).string())      == -42                        &&
  p(w(1337).string())     == 1337                       &&
  p(w(-1337).string())    == -1337                      &&
  p(w(32_767).string())   == 32_767                     &&
  p(w(-32_768).string())  == -32_768)

assert(
  w = bitInt16Writer(Endianness.Big);
  p = bitSInt16Parser(Endianness.Big);
  w(1337)                 == string(char(5), char(57))  &&
  p(w(0).string())        == 0                          &&
  p(w(1).string())        == 1                          &&
  p(w(-1).string())       == -1                         &&
  p(w(42).string())       == 42                         &&
  p(w(-42).string())      == -42                        &&
  p(w(1337).string())     == 1337                       &&
  p(w(-1337).string())    == -1337                      &&
  p(w(32_767).string())   == 32_767                     &&
  p(w(-32_768).string())  == -32_768)

assert(
  w = bitInt32Writer(Endianness.Little);
  p = bitInt32Parser(Endianness.Little);
  w(13371337)                   == string(char(201), char(7), char(204), char(0)) &&
  p(w(0).string())              == 0                                              &&
  p(w(1).string())              == 1                                              &&
  p(w(-1).string())             == -1                                             &&
  p(w(42).string())             == 42                                             &&
  p(w(-42).string())            == -42                                            &&
  p(w(1337).string())           == 1337                                           &&
  p(w(-1337).string())          == -1337                                          &&
  p(w(32_767).string())         == 32_767                                         &&
  p(w(-32_768).string())        == -32_768                                        &&
  p(w(100_000).string())        == 100_000                                        &&
  p(w(-100_000).string())       == -100_000                                       &&
  p(w(maxVal{int}()).string())  == maxVal{int}()                                  &&
  p(w(minVal{int}()).string())  == minVal{int}())

assert(
  w = bitInt32Writer(Endianness.Big);
  p = bitInt32Parser(Endianness.Big);
  w(13371337)                   == string(char(0), char(204), char(7), char(201)) &&
  p(w(0).string())              == 0                                              &&
  p(w(1).string())              == 1                                              &&
  p(w(-1).string())             == -1                                             &&
  p(w(42).string())             == 42                                             &&
  p(w(-42).string())            == -42                                            &&
  p(w(1337).string())           == 1337                                           &&
  p(w(-1337).string())          == -1337                                          &&
  p(w(32_767).string())         == 32_767                                         &&
  p(w(-32_768).string())        == -32_768                                        &&
  p(w(100_000).string())        == 100_000                                        &&
  p(w(-100_000).string())       == -100_000                                       &&
  p(w(maxVal{int}()).string())  == maxVal{int}()                                  &&
  p(w(minVal{int}()).string())  == minVal{int}())

assert(
  w = bitInt64Writer(Endianness.Little);
  p = bitInt64Parser(Endianness.Little);
  w(1337133713371337L)                        ==
    string(char(201), char(176), char(0), char(180), char(29), char(192), char(4), char(0)) &&
  p(w(0L).string())                           == 0L                                         &&
  p(w(1L).string())                           == 1L                                         &&
  p(w(-1L).string())                          == -1L                                        &&
  p(w(42L).string())                          == 42L                                        &&
  p(w(-42L).string())                         == -42L                                       &&
  p(w(1337L).string())                        == 1337L                                      &&
  p(w(-1337L).string())                       == -1337L                                     &&
  p(w(32_767L).string())                      == 32_767L                                    &&
  p(w(-32_768L).string())                     == -32_768L                                   &&
  p(w(100_000L).string())                     == 100_000L                                   &&
  p(w(-100_000L).string())                    == -100_000L                                  &&
  p(w(2_147_483_647L).string())               == 2_147_483_647L                             &&
  p(w(-2_147_483_648L).string())              == -2_147_483_648L                            &&
  p(w(9_223_372_036_854_775_807L).string())   == 9_223_372_036_854_775_807L                 &&
  p(w(minVal{long}()).string())               == minVal{long}() )

assert(
  w = bitInt64Writer(Endianness.Big);
  p = bitInt64Parser(Endianness.Big);
  w(1337133713371337L)                        ==
    string(char(0), char(4), char(192), char(29), char(180), char(0), char(176), char(201)) &&
  p(w(0L).string())                           == 0L                                         &&
  p(w(1L).string())                           == 1L                                         &&
  p(w(-1L).string())                          == -1L                                        &&
  p(w(42L).string())                          == 42L                                        &&
  p(w(-42L).string())                         == -42L                                       &&
  p(w(1337L).string())                        == 1337L                                      &&
  p(w(-1337L).string())                       == -1337L                                     &&
  p(w(32_767L).string())                      == 32_767L                                    &&
  p(w(-32_768L).string())                     == -32_768L                                   &&
  p(w(100_000L).string())                     == 100_000L                                   &&
  p(w(-100_000L).string())                    == -100_000L                                  &&
  p(w(2_147_483_647L).string())               == 2_147_483_647L                             &&
  p(w(-2_147_483_648L).string())              == -2_147_483_648L                            &&
  p(w(9_223_372_036_854_775_807L).string())   == 9_223_372_036_854_775_807L                 &&
  p(w(minVal{long}()).string())               == minVal{long}() )

// This test is left here for the first person running this on a BigEndian system, needs thorough
// testing as none of this code has ever been run on a BigEndian system.
assert(endiannessNative() == Endianness.Little)
