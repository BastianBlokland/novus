import "path.ns"
import "stream.ns"

import "std/core.ns"
import "std/diag.ns"
import "std/format.ns"
import "std/prim.ns"

// -- Types

enum FileMode =
  Create : 0,
  Open,
  Append

enum FileType =
  None      : 0,
  Regular   : 1,
  Directory : 2,
  Socket    : 3,
  Character : 4,
  Unknown   : 5

enum FileFlags =
  None       : 0b0,
  AutoRemove : 0b1

enum FileListFlags =
  None            : 0b0,
  IncludeSymlinks : 0b1

struct File =
  Path        path,
  FileMode    mode,
  FileFlags   flags,
  sys_stream  stream

// -- Conversions

fun string(FileFlags f) toEnumFlagNames(f).string()

fun string(File f)
  "(" + f.mode.string() + f.flags.string() + " " + f.path.string() + ")"

// -- Actions

act fileOpen(Path p, FileMode m, FileFlags flags = FileFlags.None) -> Either{File, Error}
  absPath     = p.pathAbsolute();
  absPathStr  = absPath.string();
  stream      = intrinsic{file_openstream}(absPathStr, int(m) | flags << 8);
  if stream.isValid() -> File(absPath, m, flags, stream)
  else                -> platformError("Failed to open file: '" + absPathStr + "'")

act readToEnd(File f) -> Either{string, Error}
  f.stream.readToEnd()

act readToEnd{T}(File f, Parser{T} parser) -> Either{T, Error}
  f.readToEnd().map(impure lambda (string s) parser.run(s))

act write(File f, string str) -> Option{Error}
  f.stream.write(str)

act write{T}(File f, Writer{T} writer, T val) -> Option{Error}
  f.write(writer.run(val))

act fileRead(Path p) -> Either{string, Error}
  p.fileOpen(FileMode.Open).map(impure lambda (File f) f.readToEnd())

act fileRead{T}(Path p, Parser{T} parser) -> Either{T, Error}
  p.fileOpen(FileMode.Open).map(impure lambda (File f) f.readToEnd(parser))

act fileWrite(Path p, string str) -> Option{Error}
  p.fileOpen(FileMode.Create).map(impure lambda (File f) f.write(str))

act fileWrite{T}(Path p, Writer{T} writer, T val) -> Option{Error}
  p.fileOpen(FileMode.Create).map(impure lambda (File f) f.write(writer, val))

act fileAppend(Path p, string str) -> Option{Error}
  p.fileOpen(FileMode.Append).map(impure lambda (File f) f.write(str))

act fileAppend{T}(Path p, Writer{T} writer, T val) -> Option{Error}
  p.fileOpen(FileMode.Append).map(impure lambda (File f) f.write(writer, val))

act fileExists(Path p)    p.fileType() != FileType.None
act fileDirExists(Path p) p.fileType() == FileType.Directory

act fileType(Path p) -> FileType
  absPathStr = p.pathAbsolute().string();
  FileType(intrinsic{file_type}(absPathStr))

act fileModTime(Path p) -> Either{DateTime, Error}
  absPathStr = p.pathAbsolute().string();
  microSinceEpoch = intrinsic{file_modification_time_microsinceepoch}(absPathStr);
  if microSinceEpoch >= 0 -> DateTime(microSinceEpoch, timezone())
  else                    -> platformError("Failed to get file modification time: '" + absPathStr + "'")

act fileSize(Path p) -> Either{ByteSize, Error}
  absPathStr = p.pathAbsolute().string();
  size = intrinsic{file_size}(absPathStr);
  if size >= 0  -> ByteSize(size)
  else          -> platformError("Failed to get file size for: '" + absPathStr + "'")

act fileCreateDir(Path p) -> Option{Error}
  absPathStr = p.pathAbsolute().string();
  if intrinsic{file_create_directory}(absPathStr) -> None()
  else -> platformError("Failed to create directory: '" + absPathStr + "'")

act fileCreatePath(Path p) -> Option{Error}
  if p.fileDirExists()  -> None()
  else                  -> actSeq(lazy fileCreatePath(p.parent()), lazy fileCreateDir(p))

act fileRemove(Path p) -> Option{Error}
  absPathStr = p.pathAbsolute().string();
  if intrinsic{file_remove}(absPathStr) || intrinsic{file_remove_directory}(absPathStr) -> None()
  else -> platformError("Failed to remove file: '" + absPathStr + "'")

act fileRename(Path old, Path new) -> Option{Error}
  absOldPathStr = old.pathAbsolute().string();
  absNewPathStr = new.pathAbsolute().string();
  if intrinsic{file_rename}(absOldPathStr, absNewPathStr) -> None()
  else -> platformError("Failed to rename file: '" + absOldPathStr + "' to '" + absNewPathStr + '\'')

act fileList(Path p, FileListFlags flags = FileListFlags.None) -> Either{List{PathAbsolute}, Error}
  absPath     = p.pathAbsolute();
  absPathStr  = absPath.string();
  fileNames   = split(intrinsic{file_list_dir}(absPathStr, flags), equals{char}['\n']);
  if platformErrorCode() != PlatformError.None -> platformError("Failed to list directory: '" + absPathStr + "'")
  else -> fileNames.mapReverse(lambda (string fileName) absPath / fileName)

// -- Utilities

act fileListReq(Path p) -> Either{List{PathAbsolute}, Error}
  pathAbs = p.pathAbsolute();
  dl      = fileList(pathAbs, FileListFlags.None);
  if dl as List{PathAbsolute} entries ->
    entries.fold(impure lambda (Either{List{PathAbsolute}, Error} result, PathAbsolute entry)
      combine(result, fileListReq(entry))
    , List(pathAbs))
  if dl as Error err -> err.code == PlatformError.FileIsNotDirectory || err.code == PlatformError.FileNoAccess
      ? List(pathAbs)
      : err

act fileRemoveReq(Path p) -> Option{Error}
  entriesOrErr = p.fileListReq();
  if entriesOrErr as Error err -> err
  if entriesOrErr as List{PathAbsolute} entries -> entries.mapReverse(
    impure lambda (PathAbsolute p) fileRemove(p)
  ).combine()

act fileCopy(Path from, Path to) -> Option{Error}
  fileOpen(from, FileMode.Open).map(impure lambda (File fromFile)
    fileOpen(to, FileMode.Create).map(impure lambda (File toFile)
      copy(fromFile.stream, toFile.stream).eitherGet(Type{Error}())
    )
  )

// -- Tests

assertEq(
  p = pathCurrent() / "file-test1.tmp";
  f = fileOpen(p, FileMode.Create, FileFlags.AutoRemove).map(
    impure lambda (File f)
      f.write("hello world")
  );
  fileRead(p), "hello world")

assertEq(
  p = pathCurrent() / "file-test2.tmp";
  f = fileOpen(p, FileMode.Create, FileFlags.AutoRemove).map(
    impure lambda (File f)
      f.write("hello world");
      f.write("hello world");
      f.write("hello world")
  );
  fileRead(p), "hello worldhello worldhello world")

assertEq(
  json  = JsonValue(JsonArray(JsonValue(true) :: JsonValue(2.0)));
  p     = pathCurrent() / "file-test3.tmp";
  f     = fileOpen(p, FileMode.Create, FileFlags.AutoRemove).map(
    impure lambda (File f)
      f.write(jsonWriter(), json)
  );
  Tuple(fileRead(p, jsonParser()), json))

assertIs(
  p = pathCurrent() / "file-test4.tmp";
  fileOpen(p, FileMode.Create, FileFlags.AutoRemove), Type{File}())

assertIs(
  p = pathCurrent() / "file-test5.tmp";
  fileOpen(p, FileMode.Open), Type{Error}())

assertIs(
  p = pathCurrent() / "file-test6.tmp";
  fileOpen(p, FileMode.Append, FileFlags.AutoRemove), Type{Error}())

assertIs(fileRemove(pathCurrent() / "non-existing-file"), Type{Error}())

assert(fileType(pathCurrent() / "non-existing-file") == FileType.None)

assert(
  p = pathCurrent() / "file-test7.tmp";
  fileType(p) == FileType.None &&
  fileOpen(p, FileMode.Create, FileFlags.AutoRemove) is File &&
  fileType(p) == FileType.Regular)

assert(
  p = pathCurrent() / "file-test8";
  fileType(p) == FileType.None &&
  fileCreateDir(p) is None &&
  fileType(p) == FileType.Directory &&
  fileRemove(p) is None &&
  fileType(p) == FileType.None)

assert(
  p = pathCurrent() / "file-test11.tmp";
  s = "Hello World";
  f = fileOpen(p, FileMode.Create, FileFlags.AutoRemove).map( impure lambda (File f) f.write(s));
  fileSize(p) == ByteSize(s.length()))
