import "tty.ns"

import "std/core.ns"
import "std/prim.ns"

// -- Settings

struct RlSettings =
  sys_stream  in,
  sys_stream  out,
  string      prompt,
  bool        useColor

// -- Terminal setup

fun rlTermOpts() TerminalOptions.NoEcho | TerminalOptions.NoBuffer

act rlSetup(RlSettings s) -> Option{Error}
  if !s.in.isTerm() || !s.out.isTerm()  -> Error("ReadLine requires an interactive input and output stream")
  else                                  -> s.in.termSetOptions(rlTermOpts())

act rlTeardown(RlSettings s) -> Option{Error}
  s.in.termUnsetOptions(rlTermOpts())

// -- Input

enum RlDir    = Forward, Backward
enum RlStride = Char, Word, Line

struct RlInputAccept
struct RlInputCancel
struct RlInputCycle   = RlDir dir
struct RlInputRemove  = RlDir dir, RlStride stride
struct RlInputMove    = RlDir dir, RlStride stride
struct RlInputText    = char c

union RlInput = RlInputAccept, RlInputCancel, RlInputCycle, RlInputRemove, RlInputMove, RlInputText

fun rlAcceptParser()
  (matchParser('\n') | matchParser('\r')) >> retParser(RlInputAccept())

fun rlCancelParser()
  (matchParser(ttyEsc()) & endParser()) >> retParser(RlInputCancel())

fun rlCycleParser()
  matchParser('\t')             >> retParser(RlInputCycle(RlDir.Forward)) |
  matchParser(ttyEsc() + "[Z")  >> retParser(RlInputCycle(RlDir.Backward))

fun rlRemoveParser()
  (matchParser(char(127))           >> retParser(RlInputRemove(RlDir.Backward, RlStride.Char))) |
  (matchParser(ttyEsc() + "[3~")    >> retParser(RlInputRemove(RlDir.Forward,  RlStride.Char))) |
  (matchParser(char(8))             >> retParser(RlInputRemove(RlDir.Backward, RlStride.Word))) |
  (matchParser(ttyEsc() + "[3;5~")  >> retParser(RlInputRemove(RlDir.Forward,  RlStride.Word)))

fun rlMoveParser()
  escapeSecParser = ( lambda (string escape, RlDir dir, RlStride type)
      matchParser(ttyEsc() + escape) >> retParser(RlInputMove(dir, type))
  );
  escapeSecParser("[D",     RlDir.Backward, RlStride.Char) |
  escapeSecParser("[C",     RlDir.Forward,  RlStride.Char) |
  escapeSecParser("[H",     RlDir.Backward, RlStride.Line) |
  escapeSecParser("[7~",    RlDir.Backward, RlStride.Line) |
  escapeSecParser("[F",     RlDir.Forward,  RlStride.Line) |
  escapeSecParser("[8~",    RlDir.Forward,  RlStride.Line) |
  escapeSecParser("[1;5D",  RlDir.Backward, RlStride.Word) |
  escapeSecParser("[1;5C",  RlDir.Forward,  RlStride.Word)

fun rlTextParser()
  charPrintableParser().map(lambda (char c) RlInputText(c))

fun rlInputParser() -> Parser{RlInput}
  ( rlAcceptParser()  |
    rlCancelParser()  |
    rlCycleParser()   |
    rlRemoveParser()  |
    rlMoveParser()    |
    rlTextParser()
  ).to(Type{RlInput}())

fun rlInputListParser() -> Parser{List{RlInput}}
  manyParser(rlInputParser())

act rlReadInput(RlSettings s, Parser{List{RlInput}} parser) -> Either{List{RlInput}, Error}
  inputOrErr = s.in.read(128);
  if inputOrErr as Error  inputErr -> inputErr
  if inputOrErr as string input    -> parser.run(input) ?? List{RlInput}()

// -- Rendering

fun rlDimWriter{T}(RlSettings s, Writer{T} w)
  s.useColor ? w.ttyStyledTextWriter(TtyStyle.FgBrightBlack) : w

act rlRenderState(RlSettings s, RlState state) -> Option{Error}
  w = ttyResetLineWriter() & rlDimWriter(s, stringWriter()) & stringWriter() & ttyCursorColWriter();
  s.out.write(w.run(Tuple(s.prompt, state.line, state.cursor + 1 + s.prompt.length())))

// -- Result

struct RlResultSuccess = string line
struct RlResultCancelled

union RlResult = RlResultSuccess, RlResultCancelled

fun rlSuccess(string line) -> RlResult
  RlResultSuccess(line)

fun rlCancel() -> RlResult
  RlResultCancelled()

// -- Loop

struct RlState = string line, int cursor, int cycle

fun rlPrevWordStart(RlState state)
  nw = state.line.indexOfLast(!isWhitespace, state.cursor - 1);
  if nw <= 0  -> 0
  else        -> state.line.indexOfLast(isWhitespace, nw) + 1

fun rlNextWordStart(RlState state)
  w = state.line.indexOf(isWhitespace, state.cursor);
  if w < 0  -> state.line.length()
  else      -> (i = state.line.indexOf(!isWhitespace, w); i > 0 ? i : state.line.length())

fun rlNextWordEnd(RlState state)
  w = state.line.indexOf(!isWhitespace, state.cursor);
  if w < 0  -> state.line.length()
  else      -> (i = state.line.indexOf(isWhitespace, w); i > 0 ? i : state.line.length())

fun rlAddChar(RlState state, char c)  RlState(state.line.insert(c.string(), state.cursor), ++state.cursor, 0)
fun rlCycle(RlState state, RlDir dir) RlState(state.line, state.cursor, dir == RlDir.Forward ? ++state.cycle : --state.cycle)
fun rlRemovePrevChar(RlState state)   RlState(state.line.remove(state.cursor - 1), max(--state.cursor, 0), 0)
fun rlRemoveNextChar(RlState state)   RlState(state.line.remove(state.cursor), state.cursor, 0)
fun rlRemovePrevWord(RlState state)   prev = state.rlPrevWordStart(); RlState(state.line.remove(prev, state.cursor - prev), prev, 0)
fun rlRemoveNextWord(RlState state)   next = state.rlNextWordEnd(); RlState(state.line.remove(state.cursor, next - state.cursor), state.cursor, 0)
fun rlCursorLeft(RlState state)       RlState(state.line, max(--state.cursor, 0), state.cycle)
fun rlCursorRight(RlState state)      RlState(state.line, min(++state.cursor, state.line.length()), state.cycle)
fun rlCursorHome(RlState state)       RlState(state.line, 0, state.cycle)
fun rlCursorEnd(RlState state)        RlState(state.line, state.line.length(), state.cycle)
fun rlCursorPrev(RlState state)       RlState(state.line, state.rlPrevWordStart(), state.cycle)
fun rlCursorNext(RlState state)       RlState(state.line, state.rlNextWordStart(), state.cycle)

fun rlApplyInput(RlState s, RlInput input) -> RlState
  if input as RlInputText txt -> s.rlAddChar(txt.c)
  if input as RlInputCycle c  -> s.rlCycle(c.dir)
  if input as RlInputRemove r -> if r.stride == RlStride.Word -> r.dir == RlDir.Backward ? s.rlRemovePrevWord() : s.rlRemoveNextWord()
                                 else                         -> r.dir == RlDir.Backward ? s.rlRemovePrevChar() : s.rlRemoveNextChar()
  if input as RlInputMove m   -> if m.stride == RlStride.Char -> m.dir == RlDir.Backward ? s.rlCursorLeft()     : s.rlCursorRight()
                                 if m.stride == RlStride.Word -> m.dir == RlDir.Backward ? s.rlCursorPrev()     : s.rlCursorNext()
                                 else                         -> m.dir == RlDir.Backward ? s.rlCursorHome()     : s.rlCursorEnd()
  else                        -> s

act rlLoop(RlSettings s) -> Either{RlResult, Error}
  state       = RlState("", 0, 0);
  inputParser = rlInputListParser();
  if rlRenderState(s, state) as Error renderErr -> renderErr
  else                                          -> rlLoop(s, state, inputParser)

act rlLoop(RlSettings s, RlState state, Parser{List{RlInput}} parser) -> Either{RlResult, Error}
  inputOrErr = rlReadInput(s, parser);
  if inputOrErr as Error          err     -> err
  if inputOrErr as List{RlInput}  inputs  ->
  (
    if inputs.any(lambda (RlInput i) i is RlInputAccept) -> rlSuccess(state.line)
    if inputs.any(lambda (RlInput i) i is RlInputCancel) -> rlCancel()
    else -> ( newState = inputs.fold(rlApplyInput, state);
              if rlRenderState(s, newState) as Error renderErr  -> renderErr
              else                                              -> self(s, newState, parser) )
  )

// -- Api

act rlSettings(Console c, string prompt = "> ") -> Either{RlSettings, Error}
  RlSettings(c.stdIn, c.stdOut, prompt, c.allowColor())

act ttyReadLine(Console c) -> Either{RlResult, Error}
  settingsOrErr = rlSettings(c);
  if settingsOrErr as Error       err       -> err
  if settingsOrErr as RlSettings  settings  -> ttyReadLine(settings)

act ttyReadLine(RlSettings s) -> Either{RlResult, Error}
  if s.rlSetup() as Error setupErr  -> setupErr
  else                              -> res = getUntilInterupt(fork rlLoop(s)) ?? rlCancel();
                                       rlTeardown(s); res
