import "list.ns"
import "time.ns"

import "std/prim.ns"

// -- Type infos

enum    PrimType      = Int, Long, Float, Bool, Char, String, SysStream, SysProcess
struct  PrimInfo      = PrimType type

struct  StructField   = string name, TypeInfo value
struct  StructInfo    = string name, List{StructField} fields

struct  UnionInfo     = string name, List{TypeInfo} entries

struct  EnumEntry     = string key, int value
struct  EnumInfo      = string name, List{EnumEntry} entries

struct  DelegateInfo  = List{TypeInfo} inputTypes, TypeInfo retType, bool isAction
struct  FutureInfo    = TypeInfo type
struct  LazyInfo      = TypeInfo type, bool isAction
struct  StaticIntInfo = int value

struct  RecursiveTypeInfo = string name

union TypeInfo =
  PrimInfo, StructInfo, UnionInfo, EnumInfo, DelegateInfo, FutureInfo, LazyInfo, StaticIntInfo, RecursiveTypeInfo

struct ReflectCtx =
  List{string} types

// -- Constructors

fun ReflectCtx() ReflectCtx(List{string}())

// -- Conversions

fun string(PrimInfo pi)
  reflectEnumKeyForVal(pi.type) ?? ""

fun string(StructField e)
  e.name + ":" + e.value.string()

fun string(StructInfo s)
  s.name + ":" + s.fields.string()

fun string(UnionInfo u)
  u.name + ":" + u.entries.string()

fun string(EnumEntry e)
  e.key + ":" + e.value.string()

fun string(EnumInfo e)
  e.name + ":" + e.entries.string()

fun string(DelegateInfo d)
  (d.isAction ? "Action:" : "Function:") + d.inputTypes.string() + "->" + d.retType.string()

fun string(FutureInfo f)
  "Future:" + f.type.string()

fun string(LazyInfo l)
  (l.isAction ? "ImpureLazy:" : "PureLazy:") + l.type.string()

fun string(StaticIntInfo si)
  "#" + si.value.string()

fun string(TypeInfo ti)
  if ti as PrimInfo pi            -> pi.string()
  if ti as StructInfo si          -> si.string()
  if ti as UnionInfo ui           -> ui.string()
  if ti as EnumInfo ei            -> ei.string()
  if ti as DelegateInfo di        -> di.string()
  if ti as FutureInfo fi          -> fi.string()
  if ti as LazyInfo li            -> li.string()
  if ti as StaticIntInfo sii      -> sii.string()
  if ti as RecursiveTypeInfo req  -> req.name

// -- Utilities

fun addType{T}(ReflectCtx rc, Type{T} t)
  ReflectCtx(t.string() :: rc.types)

// -- Reflection

fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#0}  intTypeKind)        PrimInfo(PrimType.Int)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#1}  longTypeKind)       PrimInfo(PrimType.Long)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#2}  floatTypeKind)      PrimInfo(PrimType.Float)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#3}  boolTypeKind)       PrimInfo(PrimType.Bool)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#4}  charTypeKind)       PrimInfo(PrimType.Char)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#5}  stringTypeKind)     PrimInfo(PrimType.String)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#6}  sysStreamTypeKind)  PrimInfo(PrimType.SysStream)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#7}  sysProcessTypeKind) PrimInfo(PrimType.SysProcess)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#8}  structTypeKind)     reflectStruct(t, rc)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#9}  unionTypeKind)      reflectUnion(t, rc)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#10} enumTypeKind)       reflectEnum(t)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#11} delegateTypeKind)   reflectDelegate(t, rc)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#12} futureTypeKind)     reflectFuture(t, rc)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#13} lazyTypeKind)       reflectLazy(t, rc)
fun reflect{T}(Type{T} t, ReflectCtx rc, Meta{#14} staticIntTypeKind)  StaticIntInfo(int(Meta{T}()))

fun reflect{T}(Type{T} t, ReflectCtx rc = ReflectCtx()) -> TypeInfo
  if rc.types.contains(t.string())  -> RecursiveTypeInfo(t.string())
  else                              -> reflect(t, rc.addType(t), Meta{reflect_type_kind{T}}())

// ---- Struct

fun reflectStructFields{Struct}(Type{Struct} t, ReflectCtx rc, Meta{#-1} idx, List{StructField} entries)
  entries

fun reflectStructFields{Struct, Int}(Type{Struct} t, ReflectCtx rc, Meta{Int} idx, List{StructField} entries)
  reflectStructFields(t, rc, --idx,
    StructField(
      reflectStructFieldName(t, idx),
      reflect(reflectStructFieldType(t, idx), rc)) :: entries)

fun reflectStruct{Struct}(Type{Struct} t, ReflectCtx rc = ReflectCtx()) -> StructInfo
  StructInfo(
    t.string(),
    reflectStructFields(t, rc, --reflectStructFieldCount(t), List{StructField}()))

// ---- Union

fun reflectUnionEntries{Union}(Type{Union} t, ReflectCtx rc, Meta{#-1} idx, List{TypeInfo} entries)
  entries

fun reflectUnionEntries{Union, Int}(Type{Union} t, ReflectCtx rc, Meta{Int} idx, List{TypeInfo} entries)
  reflectUnionEntries(t, rc, --idx, reflect(reflectUnionType(t, idx), rc) :: entries)

fun reflectUnion{Union}(Type{Union} t, ReflectCtx rc = ReflectCtx()) -> UnionInfo
  UnionInfo(
    t.string(),
    reflectUnionEntries(t, rc, --reflectUnionCount(t), List{TypeInfo}()))

// ---- Enum

fun reflectEnumEntries{Enum}(Type{Enum} t, Meta{#-1} idx, List{EnumEntry} entries)
  entries

fun reflectEnumEntries{Enum, Int}(Type{Enum} t, Meta{Int} idx, List{EnumEntry} entries)
  reflectEnumEntries(t, --idx, EnumEntry(reflectEnumKey(t, idx), reflectEnumVal(t, idx)) :: entries)

fun reflectEnum{Enum}(Type{Enum} t) -> EnumInfo
  EnumInfo(
    t.string(),
    reflectEnumEntries(t, --reflectEnumCount(t), List{EnumEntry}()))

// ---- Delegate

fun reflectDelegateInputs{Delegate}(Type{Delegate} t, ReflectCtx rc, Meta{#-1} idx, List{TypeInfo} inputs)
  inputs

fun reflectDelegateInputs{Delegate, Int}(Type{Delegate} t, ReflectCtx rc, Meta{Int} idx, List{TypeInfo} inputs)
  reflectDelegateInputs(t, rc, --idx, reflect(reflectDelegateInputType(t, idx), rc) :: inputs)

fun reflectDelegate{Delegate}(Type{Delegate} t, ReflectCtx rc = ReflectCtx()) -> DelegateInfo
  DelegateInfo(
    reflectDelegateInputs(t, rc, --reflectDelegateInputCount(t), List{TypeInfo}()),
    reflect(reflectDelegateRetType(t), rc),
    reflectDelegateIsAction(t))

// ---- Future

fun reflectFuture{Lazy}(Type{Lazy} t, ReflectCtx rc = ReflectCtx()) -> FutureInfo
  FutureInfo(reflect(reflectFutureType(t), rc))

// ---- Lazy

fun reflectLazy{Lazy}(Type{Lazy} t, ReflectCtx rc = ReflectCtx()) -> LazyInfo
  LazyInfo(
    reflect(reflectLazyType(t), rc),
    reflectLazyIsAction(t))

// -- Struct Utilities

// ---- Lookup struct field count

fun reflectStructFieldCount{Struct}(Type{Struct} t)
  Meta{reflect_struct_field_count{Struct}}()

// ---- Lookup struct field name from index

fun reflectStructFieldName{Struct, Idx}(Type{Struct} t, Meta{Idx} idx) -> string
  intrinsic{reflect_struct_field_name}{Struct, Idx}()

// ---- Lookup struct field type from index

fun reflectStructFieldType{Struct, Idx}(Type{Struct} t, Meta{Idx} idx)
  Type{reflect_struct_field_type{Struct, Idx}}()

// -- Union Utilities

// ---- Lookup union count

fun reflectUnionCount{Union}(Type{Union} t)
  Meta{reflect_union_count{Union}}()

// ---- Lookup union type from index

fun reflectUnionType{Union, Idx}(Type{Union} t, Meta{Idx} idx)
  Type{reflect_union_type{Union, Idx}}()

// -- Enum Utilities

// ---- Lookup key for value

fun reflectEnumKeyForVal{Enum}(Type{Enum} t, int val, Meta{#-1} idx) -> Option{string}
  None()

fun reflectEnumKeyForVal{Enum, Idx}(Type{Enum} t, int val, Meta{Idx} idx) -> Option{string}
  reflectEnumVal(t, idx) == val
    ? reflectEnumKey(t, idx)
    : reflectEnumKeyForVal(t, val, --idx)

fun reflectEnumKeyForVal{Enum}(Type{Enum} t, int val) -> Option{string}
  reflectEnumKeyForVal(t, val, --reflectEnumCount(t))

fun reflectEnumKeyForVal{Enum}(Enum val) -> Option{string}
  reflectEnumKeyForVal(Type{Enum}(), val)

// ---- Lookup value for key

fun reflectEnumValForKey{Enum}(Type{Enum} t, string key, StrComp comp, Meta{#-1} idx) -> Option{int}
  None()

fun reflectEnumValForKey{Enum, Idx}(Type{Enum} t, string key, StrComp comp, Meta{Idx} idx)  -> Option{int}
  equals(reflectEnumKey(t, idx), key, comp)
    ? reflectEnumVal(t, idx)
    : reflectEnumValForKey(t, key, comp, --idx)

fun reflectEnumValForKey{Enum}(Type{Enum} t, string key, StrComp comp = StrComp.Ordinal) -> Option{int}
  reflectEnumValForKey(t, key, comp, --reflectEnumCount(t))

// ---- Lookup number of enum entries

fun reflectEnumCount{Enum}(Type{Enum} t)
  Meta{reflect_enum_count{Enum}}()

// ---- Lookup enum key from index

fun reflectEnumKey{Enum, Idx}(Type{Enum} t, Meta{Idx} idx) -> string
  intrinsic{reflect_enum_key}{Enum, Idx}()

// ---- Lookup enum value from index

fun reflectEnumVal{Enum, Idx}(Type{Enum} t, Meta{Idx} idx) -> int
  intrinsic{reflect_enum_value}{Enum, Idx}()

// -- Delegate Utilities

// ---- Lookup delegate input count

fun reflectDelegateInputCount{Delegate}(Type{Delegate} t)
  Meta{reflect_delegate_input_count{Delegate}}()

// ---- Lookup delegate input type from index

fun reflectDelegateInputType{Delegate, Idx}(Type{Delegate} t, Meta{Idx} idx)
  Type{reflect_delegate_input_type{Delegate, Idx}}()

// ---- Lookup delegate return type

fun reflectDelegateRetType{Delegate}(Type{Delegate} t)
  Type{reflect_delegate_ret_type{Delegate}}()

// ---- Lookup if a delegate type is a action

fun reflectDelegateIsAction{Delegate}(Type{Delegate} t) -> bool
  intrinsic{reflect_delegate_is_action}{Delegate}()

// -- Future Utilities

// ---- Lookup future type

fun reflectFutureType{InnerType}(Type{future{InnerType}} t)
  Type{InnerType}()

// -- Lazy Utilities

// ---- Lookup lazy type

fun reflectLazyType{InnerType}(Type{lazy{InnerType}} t)
  Type{InnerType}()

fun reflectLazyType{InnerType}(Type{lazy_action{InnerType}} t)
  Type{InnerType}()

// ---- Lookup if a lazy type is a action

fun reflectLazyIsAction{InnerType}(Type{lazy{InnerType}} t)         false
fun reflectLazyIsAction{InnerType}(Type{lazy_action{InnerType}} t)  true

// -- Tests

assertEq(reflect(Type{int}()),          PrimInfo(PrimType.Int))
assertEq(reflect(Type{long}()),         PrimInfo(PrimType.Long))
assertEq(reflect(Type{float}()),        PrimInfo(PrimType.Float))
assertEq(reflect(Type{bool}()),         PrimInfo(PrimType.Bool))
assertEq(reflect(Type{char}()),         PrimInfo(PrimType.Char))
assertEq(reflect(Type{string}()),       PrimInfo(PrimType.String))
assertEq(reflect(Type{sys_stream}()),   PrimInfo(PrimType.SysStream))
assertEq(reflect(Type{sys_process}()),  PrimInfo(PrimType.SysProcess))

assertEq(reflect(Type{Date}()), StructInfo("Date",
  StructField("year",   PrimInfo(PrimType.Int))     ::
  StructField("month",  reflectEnum(Type{Month}())) ::
  StructField("day",    PrimInfo(PrimType.Int))
))

assertEq(reflect(Type{Option{int}}()), UnionInfo("Option{int}",
  reflect(Type{int}()) :: reflect(Type{None}())
))

assertEq(reflect(Type{List{int}}()), UnionInfo("List{int}",
  TypeInfo(StructInfo("LNode{int}",
    StructField("val",  PrimInfo(PrimType.Int)) ::
    StructField("next", RecursiveTypeInfo("List{int}"))
  )) ::
  TypeInfo(StructInfo("LEnd", List{StructField}()))
))

assertEq(reflect(Type{Month}()), EnumInfo("Month",
  EnumEntry("January",    1)   ::
  EnumEntry("February",   2)   ::
  EnumEntry("March",      3)   ::
  EnumEntry("April",      4)   ::
  EnumEntry("May",        5)   ::
  EnumEntry("June",       6)   ::
  EnumEntry("July",       7)   ::
  EnumEntry("August",     8)   ::
  EnumEntry("September",  9)   ::
  EnumEntry("October",    10)  ::
  EnumEntry("November",   11)  ::
  EnumEntry("December",   12)
))

assertEq(reflect(Type{function{int}}()), DelegateInfo(
  List{TypeInfo}(),
  reflect(Type{int}()),
  false
))

assertEq(reflect(Type{function{char, float, int}}()), DelegateInfo(
  reflect(Type{char}()) :: reflect(Type{float}()),
  reflect(Type{int}()),
  false
))

assertEq(reflect(Type{action{char, float, int}}()), DelegateInfo(
  reflect(Type{char}()) :: reflect(Type{float}()),
  reflect(Type{int}()),
  true
))

assertEq(reflect(Type{future{int}}()), FutureInfo(PrimInfo(PrimType.Int)))

assertEq(reflect(Type{lazy{int}}()), LazyInfo(PrimInfo(PrimType.Int), false))
assertEq(reflect(Type{lazy_action{int}}()), LazyInfo(PrimInfo(PrimType.Int), true))

assertEq(reflect(Type{#42}()), StaticIntInfo(42))

// -- Struct utility tests

assertEq(reflectStructFieldCount(Type{Date}()), Meta{#3}())
assertEq(reflectStructFieldCount(Type{DateTime}()), Meta{#1}())
assertEq(reflectStructFieldCount(Type{None}()), Meta{#0}())

assertEq(reflectStructFieldName(Type{Date}(), Meta{#0}()), "year")
assertEq(reflectStructFieldName(Type{Date}(), Meta{#1}()), "month")
assertEq(reflectStructFieldName(Type{Date}(), Meta{#2}()), "day")

assertEq(reflectStructFieldType(Type{Date}(), Meta{#0}()), Type{int}())
assertEq(reflectStructFieldType(Type{Date}(), Meta{#1}()), Type{Month}())
assertEq(reflectStructFieldType(Type{EnumInfo}(), Meta{#1}()), Type{List{EnumEntry}}())

// -- Union utility tests

assertEq(reflectUnionCount(Type{Option{int}}()), Meta{#2}())
assertEq(reflectUnionCount(Type{TypeInfo}()), Meta{#9}())

assertEq(reflectUnionType(Type{Option{int}}(), Meta{#0}()), Type{int}())
assertEq(reflectUnionType(Type{Option{int}}(), Meta{#1}()), Type{None}())
assertEq(reflectUnionType(Type{TypeInfo}(), Meta{#4}()), Type{DelegateInfo}())

// -- Enum utility tests

assertEq(reflectEnumCount(Type{Month}()), Meta{#12}())

assertEq(reflectEnumKey(Type{Month}(), Meta{#0}()), "January")
assertEq(reflectEnumKey(Type{Month}(), Meta{#11}()), "December")

assertEq(reflectEnumVal(Type{Month}(), Meta{#0}()), 1)
assertEq(reflectEnumVal(Type{Month}(), Meta{#11}()), 12)

assertEq(reflectEnumKeyForVal(Type{Month}(), 3), "March")
assertEq(reflectEnumKeyForVal(Type{Month}(), 12), "December")
assertEq(reflectEnumKeyForVal(Type{Month}(), 0), None())
assertEq(reflectEnumKeyForVal(Type{Month}(), 13), None())

assertEq(reflectEnumValForKey(Type{Month}(), "April"), 4)
assertEq(reflectEnumValForKey(Type{Month}(), "aPrIl", StrComp.OrdinalIgnoreCase), 4)
assertEq(reflectEnumValForKey(Type{Month}(), "Hello"), None())

// -- Delegate utility tests

assertEq(reflectDelegateInputCount(Type{function{bool}}()), Meta{#0}())
assertEq(reflectDelegateInputCount(Type{action{bool}}()), Meta{#0}())
assertEq(reflectDelegateInputCount(Type{function{int, float, bool}}()), Meta{#2}())
assertEq(reflectDelegateInputCount(Type{action{float, bool}}()), Meta{#1}())

assertEq(reflectDelegateInputType(Type{function{float, bool}}(), Meta{#0}()), Type{float}())
assertEq(reflectDelegateInputType(Type{action{float, bool}}(), Meta{#0}()), Type{float}())
assertEq(reflectDelegateInputType(Type{function{int, float, bool}}(), Meta{#0}()), Type{int}())
assertEq(reflectDelegateInputType(Type{function{int, float, bool}}(), Meta{#1}()), Type{float}())

assertEq(reflectDelegateRetType(Type{function{int, bool}}()), Type{bool}())
assertEq(reflectDelegateRetType(Type{function{bool}}()), Type{bool}())
assertEq(reflectDelegateRetType(Type{action{int, bool}}()), Type{bool}())
assertEq(reflectDelegateRetType(Type{action{bool}}()), Type{bool}())

assertNot(reflectDelegateIsAction(Type{function{bool}}()))
assert(reflectDelegateIsAction(Type{action{bool}}()))

// -- Future utility tests

assertEq(reflectFutureType(Type{future{int}}()), Type{int}())
assertEq(reflectFutureType(Type{future{List{int}}}()), Type{List{int}}())

// -- Lazy utility tests

assertEq(reflectLazyType(Type{lazy{int}}()), Type{int}())
assertEq(reflectLazyType(Type{lazy{List{int}}}()), Type{List{int}}())
assertEq(reflectLazyType(Type{lazy_action{int}}()), Type{int}())
assertEq(reflectLazyType(Type{lazy_action{List{int}}}()), Type{List{int}}())

assertNot(reflectLazyIsAction(Type{lazy{int}}()))
assert(reflectLazyIsAction(Type{lazy_action{int}}()))
