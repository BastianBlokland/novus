import "std/either.ns"
import "std/list.ns"
import "std/option.ns"
import "std/writer.ns"

// -- Types

struct Error = int code, string msg, Option{Error} next

enum ErrorWriteFlags =
  None          : 0b0,
  IncludeCodes  : 0b1

// -- Constructors

fun Error()
  Error(-1, "Unknown error")

fun Error(string msg)
  Error(-1, msg)

fun Error(int code)
  Error(code, code.string())

fun Error(int code, string msg)
  Error(code, msg, None())

// -- Operators

fun ::(Error a, Error b) -> Error
  Error(a.code, a.msg, a.next as Error n ? n :: b : b)

fun ??{T}(Either{T, Error} e, T def) -> T
  e as T val ? val : def

fun ??{T}(Either{T, Error} e, lazy{T} def) -> T
  e as T val ? val : def.get()

fun !{T}(Either{T, Error} e, Error newError) -> Either{T, Error}
  e.map(lambda (Error oldError) newError :: oldError)

fun !(Option{Error} e, Error newError) -> Option{Error}
  e.map(lambda (Error oldError) newError :: oldError)

fun !!{T}(Either{T, Error} e, Error newError) -> Either{T, Error}
  e.map(lambda (Error oldError) newError)

fun !!(Option{Error} e, Error newError) -> Option{Error}
  e.map(lambda (Error oldError) newError)

// -- Conversions

fun string(Error err)
  err.allErrors().map(lambda (Error err) "'" + err.msg + "'").string()

// -- Functions

fun count(Error err) -> int
  err.next as Error n ? 1 + n.count() : 1

fun distinct(Error err) -> Error
  err.allErrors().distinct().combine() ?? err

fun allErrors(Error err) -> List{Error}
  err.next as Error n ? List(Error(err.code, err.msg)) :: allErrors(n) : List(err)

fun combine(List{Error} err) -> Option{Error}
  err.fold(lambda (Option{Error} result, Error err)
    result as Error e ? Option(e :: err) : Option(err)
  )

fun valueOrError{T}(Pair{T, Option{Error}} p) -> Either{T, Error}
  valueOrError(p.first, p.second)

fun valueOrError{T}(Pair{T, List{Error}} p) -> Either{T, Error}
  valueOrError(p.first, p.second)

fun valueOrError{T}(T val, Option{Error} err) -> Either{T, Error}
  err as Error e ? e : val

fun valueOrError{T}(T val, List{Error} err) -> Either{T, Error}
  valueOrError(val, combine(err))

fun map{T, TResult}(Either{T, Error} v, function{T, Either{TResult, Error}} f) -> Either{TResult, Error}
  if v as T      val -> f(val)
  if v as Error  err -> err

fun map{T, TResult}(Either{T, Error} v, function{T, TResult} f) -> Either{TResult, Error}
  if v as T      val -> f(val)
  if v as Error  err -> err

// -- Writers

fun errorWriter(ErrorWriteFlags flags)
  errorWriter(noneWriter(), newlineWriter(), flags)

fun errorWriter(
    Writer{None}    prefixWriter  = noneWriter(),
    Writer{None}    sepWriter     = newlineWriter(),
    ErrorWriteFlags flags         = ErrorWriteFlags.None
  )
  includeCodes  = (flags & ErrorWriteFlags.IncludeCodes) != 0;
  codeWriter    = litWriter('[') & txtIntWriter() & litWriter("] ");
  writer        = includeCodes  ? (codeWriter & stringWriter()) .map(lambda (Error err) makePair(err.code, err.msg))
                                : stringWriter()                .map(lambda (Error err) err.msg);
  listWriter(prefixWriter & writer, sepWriter).map(lambda (Error err) err.allErrors())

// -- Actions

act map{T, TResult}(Either{T, Error} v, action{T, Either{TResult, Error}} f) -> Either{TResult, Error}
  if v as T      val -> f(val)
  if v as Error  err -> err

act map{T}(Either{T, Error} v, action{T, Option{Error}} f) -> Option{Error}
  if v as T      val -> f(val)
  if v as Error  err -> err

act map{T, TResult}(Either{T, Error} v, action{T, TResult} f) -> Either{TResult, Error}
  if v as T      val -> f(val)
  if v as Error  err -> err

// -- Tests

assert(Error("Hello").string() == "['Hello']")

assert((Error("Hello") :: Error("World")).string() == "['Hello','World']")

assert((Error("Hello") :: Error("Good") :: Error("World")).string() == "['Hello','Good','World']")

assert(
  w = errorWriter();
  w(Error()).string() == "Unknown error" &&
  w(Error(1337, "Hello") :: Error(42, "World")).string() == "Hello\nWorld")

assert(
  w = errorWriter(indentWriter(), litWriter(",")).indent();
  w(Error()).string() == "  Unknown error" &&
  w(Error(1337, "Hello") :: Error(42, "World")).string() == "  Hello,  World")

assert(
  w = errorWriter(ErrorWriteFlags.IncludeCodes);
  w(Error()).string() == "[-1] Unknown error" &&
  w(Error(1337, "Hello") :: Error(42, "World")).string() == "[1337] Hello\n[42] World")

assert(
  w = errorWriter(indentWriter(), litWriter(","), ErrorWriteFlags.IncludeCodes).indent();
  w(Error()).string() == "  [-1] Unknown error" &&
  w(Error(1337, "Hello") :: Error(42, "World")).string() == "  [1337] Hello,  [42] World")

assert(
  Error("Hello").count() == 1 &&
  (Error("Hello") :: Error("World")).count() == 2 &&
  (Error("Good") :: Error("Hello") :: Error("World")).count() == 3)

assert(
  err = Error("Hello") :: Error("Good") :: Error("World");
  err.allErrors() == Error("Hello") :: Error("Good") :: Error("World") :: List{Error}())

assert(
  errs = Error("Hello") :: Error("Good") :: Error("World") :: List{Error}();
  errs.combine() == Error("Hello") :: Error("Good") :: Error("World"))

assert(
  Error("Hello").distinct() == Error("Hello") &&
  (Error() :: Error()).distinct() == Error() &&
  (Error("Hello") :: Error("World")).distinct() == Error("Hello") :: Error("World") &&
  (Error("Hello") :: Error("World") :: Error("Hello")).distinct() == Error("Hello") :: Error("World"))

assert(
  v = Either{int, Error}(42);
  v.map(lambda (int val) val * 2) == 84)

assert(
  v = Either{int, Error}(Error());
  v.map(lambda (int val) 42) == Error())

assert(
  v = Either{int, Error}(42);
  v.map(lambda (int val) val > 100 ? val : Error("Test")) == Error("Test"))

assert(
  v = Either{int, Error}(Error());
  v.map(lambda (int val) val > 100 ? val : Error("Test")) == Error())

assert(
  v = Either{int, Error}(Error("Low level error"));
  (v ! Error("Better error")) == Error("Better error") :: Error("Low level error"))

assert(
  v = Either{int, Error}(42);
  (v ! Error("Better error")) == 42)

assert(
  v = Option(Error("Low level error"));
  (v ! Error("Better error")) == Error("Better error") :: Error("Low level error"))

assert(
  v = Option{Error}();
  (v ! Error("Better error")) == None())

assert(
  v = Either{int, Error}(Error("Low level error"));
  (v !! Error("Better error")) == Error("Better error"))

assert(
  v = Either{int, Error}(42);
  (v !! Error("Better error")) == 42)

assert(
  v = Option(Error("Low level error"));
  (v !! Error("Better error")) == Error("Better error"))

assert(
  v = Option{Error}();
  (v !! Error("Better error")) == None())

assert(
  valueOrError(42, None())        == 42 &&
  valueOrError(42, Error("Test")) == Error("Test") )

assert(
  valueOrError(42, List{Error}())                                     == 42 &&
  valueOrError(42, Error("Test") :: List{Error}())                    == Error("Test") &&
  valueOrError(42, Error("Test") :: Error("Test2") :: List{Error}())  == Error("Test") :: Error("Test2") )

// -- Impure Tests

assert(
  v = Either{int, Error}(42);
  v.map(impure lambda (int val) val * 2) == 84)

assert(
  v = Either{int, Error}(Error("Test"));
  v.map(impure lambda (int val) val) == Error("Test"))

assert(
  v = Either{int, Error}(42);
  v.map(impure lambda (int val) val > 100 ? val : Error("Test")) == Error("Test"))

assert(
  v = Either{int, Error}(42);
  v.map(impure lambda (int val) val > 100 ? Option(Error("Test")) : None())  is None &&
  v.map(impure lambda (int val) val > 30 ? Option(Error("Test")) : None())   == Error("Test"))

assert(
  v = Either{int, Error}(Error());
  v.map(impure lambda (int val) val > 100 ? val : Error("Test")) == Error())
