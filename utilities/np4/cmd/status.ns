import "std.ns"

import "../perforce/runner.ns"
import "../utils/fork.ns"
import "../utils/style.ns"

// -- Types.

struct StatusData =
  P4Config            config,
  P4ClientInfo        clientInfo,
  P4StreamInfo        streamInfo,
  List{StatusResolve} pendingResolves,
  List{StatusChange}  pendingChanges,
  List{P4OpenFile}    defaultOpenFiles

struct StatusLimitedList{T} = List{T} files, int count, int max, bool truncated

struct StatusChange =
  P4ChangeInfo                    info,
  StatusLimitedList{P4OpenFile}   openFiles,
  StatusLimitedList{P4FileInfo}   shelvedFiles

struct StatusResolve =
  P4ClientFile    clientFile,
  P4ResolveType   resolveType

// -- Utilities.

fun statusFilterPending(P4ChangeInfo changeInfo, P4Config cfg) -> bool
  !p4ChangeIsHidden(cfg, changeInfo.change)

fun statusToLimitedList{T}(List{T} files, int max) -> StatusLimitedList{T}
  count = files.length();
  truncated = count > max;
  StatusLimitedList{T}(files[0, max], min(count, max), max, truncated)

fun statusToResolve(P4ResolveFile resolve, P4ClientInfo clientInfo) -> Either{StatusResolve, Error}
  clientFileOrErr = absPathToP4ClientFile(clientInfo, resolve.clientFile);
  clientFileOrErr.map(lambda (P4ClientFile clientFile) StatusResolve(clientFile, resolve.resolveType))

fun statusToResolves(List{P4ResolveFile} resolves, P4ClientInfo clientInfo) -> Either{List{StatusResolve}, Error}
  resolves.map(statusToResolve[clientInfo]).split().valueOrError()

// -- Actions.

act statusQueryChange(P4ChangeInfo changeInfo, P4Config cfg, StatusSettings settings) -> Either{StatusChange, Error}
  waitForForks(Tuple(
    fork p4RunGetOpenFiles(cfg, cfg.client, changeInfo.change, settings.filesMax + 1),
    fork p4RunGetDepotFiles(cfg, changeInfo.change, settings.filesMax + 1))
  ).map(lambda (Tuple{List{P4OpenFile}, List{P4FileInfo}} res)
    StatusChange(
      changeInfo,
      statusToLimitedList(res.f1, settings.filesMax),
      statusToLimitedList(res.f2, settings.filesMax))
   )

act statusQueryChanges(P4Config cfg, StatusSettings settings) -> Either{List{StatusChange}, Error}
  changeInfosOrErr = p4RunChangeInfos(cfg, cfg.client, P4ChangeStatus.Pending, settings.changesMax);
  changeInfosOrErr.map(impure lambda (List{P4ChangeInfo} changes)
        changes
          .filter(statusFilterPending[cfg])
          .parallelMap(statusQueryChange[settings][cfg])
          .split()
          .valueOrError()
    )

act statusQuery(P4Config cfg, StatusSettings settings) -> Either{StatusData, Error}
  waitForForks(Tuple(
    fork p4RunClientInfo(cfg, cfg.client),
    fork p4RunCurrentStreamInfo(cfg),
    fork p4RunPendingResolves(cfg),
    fork statusQueryChanges(cfg, settings),
    fork p4RunGetOpenFiles(cfg, cfg.client, p4DefaultChange(), settings.filesMax))
  ).map(impure lambda (Tuple{ P4ClientInfo,
                              P4StreamInfo,
                              List{P4ResolveFile},
                              List{StatusChange},
                              List{P4OpenFile}} res)
    resolvesOrErr = statusToResolves(res.f3, res.f1);
    resolvesOrErr.map(lambda (List{StatusResolve} resolves)
      StatusData(cfg, res.f1, res.f2, resolves, res.f4, res.f5))
    )

// -- Writers.

fun statusStyleForFileOp(P4FileOp op) -> Style
  if op == P4FileOp.Add         -> Style.OpAdd
  if op == P4FileOp.Edit        -> Style.OpEdit
  if op == P4FileOp.Delete      -> Style.OpDelete
  if op == P4FileOp.Integrate   -> Style.OpIntegrate
  if op == P4FileOp.Branch      -> Style.OpBranch
  if op == P4FileOp.MoveAdd     -> Style.OpMove
  if op == P4FileOp.MoveDelete  -> Style.OpMove
  else                          -> Style.Important

fun statusClientWriter(StyleCtx ctx) -> Writer{StatusData}
  (
    stringWriter() &
    litWriter(" (") & pathAbsWriter().styledWriter(ctx, Style.Detail) & litWriter(")")
  ).map(lambda (StatusData data) Tuple(data.clientInfo.client.string(), data.clientInfo.root))

fun statusStreamWriter(StyleCtx ctx) -> Writer{StatusData}
  (
    stringWriter() &
    litWriter(" (") & enumKeyWriter(Type{P4StreamType}()).styledWriter(ctx, Style.Detail) & litWriter(")") &
    ?(litWriter(" Parent: ").styledWriter(ctx, Style.Important) & stringWriter())
  ).map(lambda (StatusData data)
    Tuple(  data.streamInfo.stream.string(),
            data.streamInfo.type,
            data.streamInfo.parent.map(lambda (P4Stream s) s.string()))
  )

fun statusOpenFileWriter(StyleCtx ctx, int widthMax) -> Writer{P4OpenFile}
  (
    styleWriter(ctx) & enumKeyWriter(Type{P4FileOp}()) &
    litWriter(": ") & pathRelWriter() & styleResetWriter(ctx) &
    (litWriter(" #") & txtIntWriter()).styledWriter(ctx, Style.Detail)
  ).map(lambda (P4OpenFile c) Tuple(statusStyleForFileOp(c.Action), c.Action, c.clientFile.path, c.rev))

fun statusResolveFileWriter(StyleCtx ctx, int widthMax) -> Writer{StatusResolve}
  (
    (enumKeyWriter(Type{P4ResolveType}()) & litWriter(" resolve")).styledWriter(ctx, Style.Resolve) &
    litWriter(": ") & pathRelWriter().styledWriter(ctx, Style.Important)
  ).map(lambda (StatusResolve c) Tuple(c.resolveType, c.clientFile.path))

fun statusLimitedListCountWriter{T}() -> Writer{StatusLimitedList{T}}
  (
    txtIntWriter() & ?litWriter("+") & litWriter(" files")
  ).map(lambda (StatusLimitedList{T} l) Tuple(l.count, l.truncated))

fun StatusLimitedListWriter{T}(Writer{T} w) -> Writer{StatusLimitedList{T}}
  (
    listWriter(newlineWriter() & indentWriter() & w) &
    ?(newlineWriter() & indentWriter() & litWriter("... (use '--files-max [COUNT]' to increase limit)"))
  ).map(lambda (StatusLimitedList{T} l) Tuple(l.files, l.truncated))

fun statusChangesWriter(StyleCtx ctx, int widthMax) -> Writer{StatusChange}
  shelveWrite = newlineWriter() & indentWriter() & litWriter("Shelved: ") & statusLimitedListCountWriter{P4FileInfo}();
  (
    litWriter("[") &
    stringWriter().styledWriter(ctx, Style.Important) &
    litWriter("] ") &
    stringWriter() &
    (
      ?shelveWrite.styledWriter(ctx, Style.Important) &
      StatusLimitedListWriter(statusOpenFileWriter(ctx, widthMax))
    ).indent()
  ).map(lambda (StatusChange c)
    Tuple(
      c.info.change.string(),
      c.info.p4ChangeShortDesc(widthMax - 16),
      Tuple(c.shelvedFiles.count > 0 ? Option(c.shelvedFiles) : None(), c.openFiles))
  )

fun statusOutputWriter(StyleCtx ctx, int widthMax) -> Writer{StatusData}
  (
    litWriter("Client: ").styledWriter(ctx, Style.Important) & statusClientWriter(ctx) & newlineWriter() &
    litWriter("Stream: ").styledWriter(ctx, Style.Important) & statusStreamWriter(ctx) & newlineWriter() &
    ?(
      litWriter("Resolves: ").styledWriter(ctx, Style.Important) & newlineWriter() &
      indentedListWriter(statusResolveFileWriter(ctx, widthMax))
    ) &
    ?(
      litWriter("Pending: ").styledWriter(ctx, Style.Important) & newlineWriter() &
      indentedListWriter(statusChangesWriter(ctx, widthMax))
    ) &
    ?(
      litWriter("Default: ").styledWriter(ctx, Style.Important) & newlineWriter() &
      indentedListWriter(statusOpenFileWriter(ctx, widthMax))
    )
  ).map(lambda (StatusData d)
    Tuple(d, d, d.pendingResolves.noneIfEmpty(), d.pendingChanges.noneIfEmpty(), d.defaultOpenFiles.noneIfEmpty())
  )

// -- Driver.

struct StatusSettings =
  bool        noColor,
  Option{int} widthMax,
  int         changesMax,
  int         filesMax

fun cliDefaults(Type{StatusSettings} t)
  CliDefault("changes-max",  "100") ::
  CliDefault("files-max",    "100")

act statusCmd(StatusSettings s) -> Option{Error}
  c         = consoleOpen().failOnError();
  widthMax  = s.widthMax ?? (c.termGetWidth() ?? 80);
  styleCtx  = StyleCtx(!s.noColor && c.allowColor());
  writer    = statusOutputWriter(styleCtx, widthMax);
  dataOrErr = loadP4Config().map(statusQuery[s]);
  if dataOrErr as Error      err  -> err
  if dataOrErr as StatusData data -> c.writeOut(writer, data)
