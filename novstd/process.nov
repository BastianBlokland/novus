import "std/console.nov"
import "std/list.nov"

// -- Types

struct ProcessId  = long id
struct ExitCode   = int code

enum Signal =
  Interupt : 0

struct Process =
  string      cmdLine,
  sys_process handle,
  ProcessId   id,
  sys_stream  stdIn,
  sys_stream  stdOut,
  sys_stream  stdErr

struct ProcessResult =
  string    stdOut,
  string    stdErr,
  ExitCode  exitCode

// -- Conversions

fun string(ProcessId p)
  "[" + p.id + "]"

fun string(ExitCode p)
  p.code.string()

fun string(Process p)
  "(" + p.id + ", " + p.cmdLine + ")"

fun string(ProcessResult r)
  "(" + r.exitCode + ")"

// -- Functions

fun toCmdLine(string prog, List{string} args) -> string
  escapeSingleQuotes = (lambda (string s) s.replace("'", "\\'"));
  (prog :: args).map(escapeSingleQuotes).string("'", "' '", "'")

fun isSuccess(ExitCode ec)
  ec.code == 0

fun isSuccess(ProcessResult r)
  r.exitCode.isSuccess()

// -- Actions

act run(string prog, List{string} args) -> Process
  run(toCmdLine(prog, args))

act run(string cmdLine) -> Process
  handle = intrinsic{process_start}(cmdLine);
  Process(
    cmdLine,
    handle,
    ProcessId(intrinsic{process_getid}(handle)),
    intrinsic{process_openstream}(handle, 0),
    intrinsic{process_openstream}(handle, 1),
    intrinsic{process_openstream}(handle, 2))

act sendInterupt(Process p) -> bool
  p.sendSignal(Signal.Interupt)

act sendSignal(Process p, Signal s) -> bool
  intrinsic{process_sendsignal}(p.handle, int(s))

act wait(Process p) -> ProcessResult
  ProcessResult(
    p.stdOut.readToEnd(),
    p.stdErr.readToEnd(),
    ExitCode(intrinsic{process_block}(p.handle)))

act waitAsync(Process p) -> future{ProcessResult}
  fork p.wait()

// -- Tests

assert(
  p = run("cmake", "-E" :: "echo" :: "Hello world" :: List{string}());
  p.id.id > 0 &&
  p.cmdLine == "'cmake' '-E' 'echo' 'Hello world'")

assert(
  r = run("cmake", "-E" :: "echo" :: "Hello world").wait();
  r.stdOut.startsWith("Hello world") &&
  r.stdErr.isEmpty() &&
  r.exitCode == ExitCode(0))

assert(
  r = run("cmake", "--version" :: List{string}()).wait();
  r.stdOut.startsWith("cmake version") &&
  r.stdErr.isEmpty() &&
  r.exitCode == ExitCode(0))

assert(
  r = run("cmake", "--invalid" :: List{string}()).wait();
  r.stdOut.isEmpty() &&
  r.stdErr.startsWith("CMake Error") &&
  r.exitCode == ExitCode(1))
