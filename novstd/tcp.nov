import "std/future.nov"
import "std/ip.nov"
import "std/option.nov"
import "std/parallel.nov"

// -- Types

struct TcpConnection =
  sys_stream socket

struct TcpServerState =
  int connectionCounter

struct TcpServerSettings =
  IpFamily                                              family,
  int                                                   port,
  int                                                   maxBacklog,
  action{TcpConnection, TcpServerState, Option{Error}}  clientHandler,
  action{TcpServerState, bool}                          cancelPredicate

// -- Constructors

fun TcpServerSettings(int port, action{TcpConnection, TcpServerState, Option{Error}} clientHandler)
  TcpServerSettings(IpFamily.V4, port, clientHandler)

fun TcpServerSettings(IpFamily family, int port, action{TcpConnection, TcpServerState, Option{Error}} clientHandler)
  TcpServerSettings(family, port, 64, clientHandler)

fun TcpServerSettings(IpFamily family, int port, int maxBacklog, action{TcpConnection, TcpServerState, Option{Error}} clientHandler)
  TcpServerSettings(
    family,
    port,
    maxBacklog,
    clientHandler,
    impure lambda (TcpServerState state) interuptIsRequested())

// -- Connection

act write(TcpConnection c, string str) -> Option{Error}
  c.socket.write(str)
    ? None()
    : Error("Failed to write to the socket")

act write(TcpConnection c, char ch) -> Option{Error}
  c.socket.write(ch)
    ? None()
    : Error("Failed to write to the socket")

act write{T}(TcpConnection c, Writer{T} writer, T val) -> Option{Error}
  c.write(writer.run(val))

// -- Client

act tcpConnection(IpAddress addr) -> Either{TcpConnection, Error}
  tcpConnection(addr, 8080)

act tcpConnection(IpAddress addr, int port) -> Either{TcpConnection, Error}
  binAddr = ipBinWriter().run(addr);
  socket  = intrinsic{tcp_connection_open}(binAddr, IpFamily(addr).int(), port);
  if socket.isValid() -> TcpConnection(socket)
  else                -> Error("Failed to open connection to: '" + addr.string() + " [" + port + "]")

act tcpConnectionAsync(IpAddress addr) -> future{Either{TcpConnection, Error}}
  fork tcpConnection(addr)

act tcpConnectionAsync(IpAddress addr, int port) -> future{Either{TcpConnection, Error}}
  fork tcpConnection(addr, port)

// -- Server

act tcpServer(TcpServerSettings settings) -> Either{TcpServerState, Error}
  serverSocket = intrinsic{tcp_server_start}(settings.family.int(), settings.port, settings.maxBacklog);
  if !serverSocket.isValid() -> Error("Failed to start tcp-server")
  else ->
    teardown = (impure lambda () -> bool
      intrinsic{tcp_shutdown}(serverSocket)
    );
    acceptCon = (impure lambda () -> Either{TcpConnection, Error}
      socket = intrinsic{tcp_server_accept}(serverSocket);
      if socket.isValid() -> TcpConnection(socket)
      else                -> teardown(); Error("Failed to accept new connection")
    );
    loop = (impure lambda (
      future{Either{TcpConnection, Error}} futureConnection,
      List{future{Option{Error}}}          connections,
      TcpServerState                       state)

        if futureConnection.get(milliseconds(100)) as Either{TcpConnection, Error} newConnection ->
        (
          if newConnection as Error          err  -> teardown(); err
          if newConnection as TcpConnection  c    ->
            newState = TcpServerState(state.connectionCounter + 1);
            self(fork acceptCon(), fork settings.clientHandler(c, newState) :: connections, newState)
        )
        else ->
        (
          conErrOpt = connections.map(    impure lambda (future{Option{Error}} c) c.poll().unwrap()).combine();
          remCons   = connections.filter( impure lambda (future{Option{Error}} c) c.poll() is None);
          if conErrOpt as Error conErr        -> teardown(); conErr
          if !settings.cancelPredicate(state) -> self(futureConnection, remCons, state)
          else                                -> teardown(); state
        )
    );
    loop(fork acceptCon(), List{future{Option{Error}}}(), TcpServerState(0))

// -- Tests

assert(
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state) Option{Error}());
  tcpServer(TcpServerSettings(IpFamily.V4, -1, 64, clientHandler))          is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V4, 65536, 64, clientHandler))       is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V4, intMax(), 64, clientHandler))    is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V4, 5000, intMax(), clientHandler))  is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V6, -1, 64, clientHandler))          is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V6, 65536, 64, clientHandler))       is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V6, intMax(), 64, clientHandler))    is Error  &&
  tcpServer(TcpServerSettings(IpFamily.V6, 5010, intMax(), clientHandler))  is Error
)

assert(
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state)
    c.write(c.socket.readLine() + '\n')
  );
  fork tcpServer(TcpServerSettings(IpFamily.V4, 5011, clientHandler));
  client = (impure lambda(string message)
    c = tcpConnection(ipV4Loopback(), 5011).failOnError();
    c.write(message + '\n').failOnError();
    c.socket.readLine()
  );
  parallelFor(25, impure lambda (int i)
    msg = string("Hello from the network", i);
    client(msg) == msg
  ).all()
)

assert(
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state)
    c.write(c.socket.readLine() + '\n')
  );
  fork tcpServer(TcpServerSettings(IpFamily.V6, 5012, clientHandler));
  client = (impure lambda(string message)
    c = tcpConnection(ipV6Loopback(), 5012).failOnError();
    c.write(message + '\n').failOnError();
    c.socket.readLine()
  );
  parallelFor(25, impure lambda (int i)
    msg = string("Hello from the network", i);
    client(msg) == msg
  ).all()
)

assert(
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state)
    Option(Error("Did not go well"))
  );
  res = fork tcpServer(TcpServerSettings(IpFamily.V6, 5013, clientHandler));
  client = tcpConnection(ipV6Loopback(), 5013).failOnError();
  res.get() == Error("Did not go well")
)

assert(
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state)
    c.write("hello")
  );
  cancelPredicate = (impure lambda (TcpServerState state)
    true
  );
  res = tcpServer(TcpServerSettings(IpFamily.V6, 5014, 64, clientHandler, cancelPredicate));
  if res as Error          err  -> printErr(err); false
  if res as TcpServerState s    -> s == TcpServerState(0)
)

assert(
  cancelPredicate = (impure lambda (TcpServerState state)
    state.connectionCounter == 25
  );
  clientHandler = (impure lambda (TcpConnection c, TcpServerState state)
    c.write("Hello\n")
  );
  server = fork tcpServer(TcpServerSettings(IpFamily.V6, 5015, 64, clientHandler, cancelPredicate));
  parallelFor(25, impure lambda (int i)
    tcpConnection(ipV6Loopback(), 5015)
  );
  if server.get() as Error          err  -> printErr(err); false
  if server.get() as TcpServerState s    -> s == TcpServerState(25)
)
