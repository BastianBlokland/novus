import "std/future.nov"
import "std/ip.nov"
import "std/option.nov"
import "std/parallel.nov"

// -- Types

struct TcpConnection =
  sys_stream socket

struct TcpServer =
  int         maxBacklog,
  sys_stream  socket,
  int         port

struct TcpServerLoopContext =
  action{TcpConnection, Option{Error}}  clientHandler,
  action{bool}                          predicate

// -- Constructors

fun TcpServerLoopContext(action{TcpConnection, Option{Error}} clientHandler)
  TcpServerLoopContext(
    clientHandler,
    impure lambda () !interuptIsRequested()
  )

// -- Connection

act write(TcpConnection c, string str) -> Option{Error}
  c.socket.write(str)
    ? None()
    : Error("Failed to write to the socket")

act write(TcpConnection c, char ch) -> Option{Error}
  c.socket.write(ch)
    ? None()
    : Error("Failed to write to the socket")

act write{T}(TcpConnection c, Writer{T} writer, T val) -> Option{Error}
  c.write(writer.run(val))

// -- Client

act tcpConnection(IpAddress addr) -> Either{TcpConnection, Error}
  tcpConnection(addr, 8080)

act tcpConnectionAsync(IpAddress addr) -> future{Either{TcpConnection, Error}}
  fork tcpConnection(addr)

act tcpConnection(IpAddress addr, int port) -> Either{TcpConnection, Error}
  binAddr = ipBinWriter().run(addr);
  socket  = tcpOpenConnection(binAddr, IpFamily(addr).int(), port);
  if socket.streamCheckValid()  -> TcpConnection(socket)
  else                          -> Error("Failed to open connection to: '" + addr.string() + " [" + port + "]")

act tcpConnectionAsync(IpAddress addr, int port) -> future{Either{TcpConnection, Error}}
  fork tcpConnection(addr, port)

// -- Server

act tcpServer(IpFamily family) -> Either{TcpServer, Error}
  tcpServer(family, 8080)

act tcpServer(IpFamily family, int port) -> Either{TcpServer, Error}
  tcpServer(family, port, 64)

act tcpServer(IpFamily family, int port, int maxBacklog) -> Either{TcpServer, Error}
  socket = tcpStartServer(family.int(), port, maxBacklog);
  if socket.streamCheckValid() -> TcpServer(maxBacklog, socket, port)
  else                         -> Error("Failed to start tcp-server")

act tcpAcceptConnection(TcpServer server) -> Either{TcpConnection, Error}
  socket = tcpAcceptConnection(server.socket);
  if socket.streamCheckValid()  -> TcpConnection(socket)
  else                          -> Error("Failed to accept new connection")

act tcpAcceptConnectionAsync(TcpServer server) -> future{Either{TcpConnection, Error}}
  fork server.tcpAcceptConnection()

act tcpServerLoop(IpFamily family, int port, TcpServerLoopContext ctx) -> Option{Error}
  tcpServer(family, port).map(impure lambda (TcpServer svr) svr.tcpServerLoop(ctx))

act tcpServerLoop(IpFamily family, int port, int maxBacklog, TcpServerLoopContext ctx) -> Option{Error}
  tcpServer(family, port, maxBacklog).map(impure lambda (TcpServer svr) svr.tcpServerLoop(ctx))

act tcpServerLoop(TcpServer svr, TcpServerLoopContext ctx) -> Option{Error}
  loop = (impure lambda (
    future{Either{TcpConnection, Error}} futureConnection,
    List{future{Option{Error}}}          connections)

      if futureConnection.get(milliseconds(100)) as Either{TcpConnection, Error} newConnection ->
      (
        if newConnection as Error          err  -> err
        if newConnection as TcpConnection  c    ->
          self(svr.tcpAcceptConnectionAsync(), fork ctx.clientHandler(c) :: connections)
      )
      else ->
      (
        conErrOpt = connections.map(    impure lambda (future{Option{Error}} c) c.poll().unwrap()).combine();
        remCons   = connections.filter( impure lambda (future{Option{Error}} c) c.poll() is None);
        if conErrOpt as Error conErr  -> conErr
        if ctx.predicate()            -> self(futureConnection, remCons)
        else                          -> None()
      )
  );
  loop(
    svr.tcpAcceptConnectionAsync(),
    List{future{Option{Error}}}())

// -- Tests

assert(
  tcpServer(IpFamily.V4, -1)              is Error  &&
  tcpServer(IpFamily.V4, 65536)           is Error  &&
  tcpServer(IpFamily.V4, intMax())        is Error  &&
  tcpServer(IpFamily.V4, 5000, intMax())  is Error  &&
  tcpServer(IpFamily.V6, -1)              is Error  &&
  tcpServer(IpFamily.V6, 65536)           is Error  &&
  tcpServer(IpFamily.V6, intMax())        is Error  &&
  tcpServer(IpFamily.V6, 5000, intMax())  is Error
)

assert(
  server    = tcpServer(IpFamily.V4, 5001).failOnError();
  client    = tcpConnection(ipV4Loopback(), 5001).failOnError();
  serverCon = server.tcpAcceptConnection().failOnError();

  serverCon.write("Hello world\n").failOnError();
  client.socket.readLine() == "Hello world"
)

assert(
  server    = tcpServer(IpFamily.V6, 5002).failOnError();
  client    = tcpConnection(ipV6Loopback(), 5002).failOnError();
  serverCon = server.tcpAcceptConnection().failOnError();

  serverCon.write("Hello world\n").failOnError();
  client.socket.readLine() == "Hello world"
)

assert(
  fork tcpServerLoop(IpFamily.V6, 5003, TcpServerLoopContext(impure lambda(TcpConnection c)
    c.write(c.socket.readLine() + '\n')
  ));
  client = (impure lambda(string message)
    c = tcpConnection(ipV6Loopback(), 5003).failOnError();
    c.write(message + '\n').failOnError();
    c.socket.readLine()
  );
  parallelFor(100, impure lambda (int i)
    msg = string("Hello from the network", i);
    client(msg) == msg
  ).all()
)

assert(
  server = tcpServer(IpFamily.V6, 5004).failOnError();
  client = tcpConnection(ipV6Loopback(), 5004).failOnError();

  res = tcpServerLoop(server, TcpServerLoopContext(impure lambda(TcpConnection c)
    Option(Error("Did not go well"))
  ));
  res == Error("Did not go well")
)

assert(
  server = tcpServer(IpFamily.V6, 5005).failOnError();
  client = tcpConnection(ipV6Loopback(), 5005).failOnError();

  clientHandler = (impure lambda (TcpConnection c)
    c.write("hello")
  );
  predicate = (impure lambda ()
    false
  );
  tcpServerLoop(server, TcpServerLoopContext(clientHandler, predicate)) is None
)
