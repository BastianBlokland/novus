import "std/console.nov"
import "std/path.nov"
import "std/time.nov"
import "std/version.nov"

// -- Types

enum Platform =
  Linux   : 1,
  MacOs   : 2,
  Windows : 3

enum PlatformError =
  Unknown                       : 001,
  FeatureNetworkNotEnabled      : 100,
  StreamOptionsNotSupported     : 200,
  StreamNoDataAvailable         : 201,
  StreamReadNotSupported        : 202,
  StreamWriteNotSupported       : 203,
  ConsoleUnknownError           : 300,
  ConsoleNotPresent             : 301,
  FileUnknownError              : 400,
  FileNoAccess                  : 401,
  FileNotFound                  : 402,
  FileInvalidFileName           : 403,
  FilePathTooLong               : 404,
  FileDiskFull                  : 405,
  FileLocked                    : 406,
  TcpUnknownError               : 500,
  TcpInvalidSocket              : 501,
  TcpInvalidServerSocket        : 502,
  TcpAlreadyInProcess           : 503,
  TcpNetworkDown                : 504,
  TcpSocketCouldNotBeAllocated  : 505,
  TcpInvalidPort                : 506,
  TcpInvalidBacklog             : 507,
  TcpInvalidAddressFamily       : 508,
  TcpNoAccess                   : 509,
  TcpAddressInUse               : 510,
  TcpAddressUnavailable         : 511,
  TcpInvalidAddress             : 512,
  TcpNetworkUnreachable         : 513,
  TcpAddressFamiliyNotSupported : 514,
  TcpConnectionRefused          : 515,
  TcpTimeout                    : 516,
  TcpAddressNotFound            : 517,
  TcpRemoteResetConnection      : 518,
  TcpSocketIsDead               : 519,
  SleepFailed                   : 600

// -- Conversions

fun string(Platform p)
  if p == Platform.Linux    -> "Linux"
  if p == Platform.MacOs    -> "MacOs"
  if p == Platform.Windows  -> "Windows"
  else                      -> "Unknown"

fun string(PlatformError err)
  if err == PlatformError.Unknown                       -> "Unknown"
  if err == PlatformError.FeatureNetworkNotEnabled      -> "Network feature not enabled"
  if err == PlatformError.StreamOptionsNotSupported     -> "Stream does not support the given options"
  if err == PlatformError.StreamNoDataAvailable         -> "No data available"
  if err == PlatformError.StreamReadNotSupported        -> "Stream does not support reading"
  if err == PlatformError.StreamWriteNotSupported       -> "Stream does not support writing"
  if err == PlatformError.ConsoleUnknownError           -> "Unknown console error occured"
  if err == PlatformError.ConsoleNotPresent             -> "Console not present"
  if err == PlatformError.FileUnknownError              -> "Unknown file error occured"
  if err == PlatformError.FileNoAccess                  -> "File access denied"
  if err == PlatformError.FileNotFound                  -> "File not found"
  if err == PlatformError.FileInvalidFileName           -> "File name is not valid for the underlying filesystem"
  if err == PlatformError.FilePathTooLong               -> "File path is too long for the underlying filesystem"
  if err == PlatformError.FileDiskFull                  -> "Not enough space left on the underlying filesystem"
  if err == PlatformError.FileLocked                    -> "File is locked"
  if err == PlatformError.TcpUnknownError               -> "Unknown Tcp error occured"
  if err == PlatformError.TcpInvalidSocket              -> "Invalid Tcp socket"
  if err == PlatformError.TcpInvalidServerSocket        -> "Invalid Tcp server socket"
  if err == PlatformError.TcpAlreadyInProcess           -> "Tcp operation already in progess"
  if err == PlatformError.TcpNetworkDown                -> "Tcp network down"
  if err == PlatformError.TcpSocketCouldNotBeAllocated  -> "New Tcp socket could not be allocated"
  if err == PlatformError.TcpInvalidPort                -> "Invalid Tcp port"
  if err == PlatformError.TcpInvalidBacklog             -> "Invalid Tcp backlog"
  if err == PlatformError.TcpInvalidAddressFamily       -> "Invalid Tcp address-family"
  if err == PlatformError.TcpNoAccess                   -> "Tcp access denied"
  if err == PlatformError.TcpAddressInUse               -> "Tcp address already in use"
  if err == PlatformError.TcpAddressUnavailable         -> "Tcp address cannot be assigned"
  if err == PlatformError.TcpInvalidAddress             -> "Invalid Tcp address"
  if err == PlatformError.TcpNetworkUnreachable         -> "Tcp network unreachable"
  if err == PlatformError.TcpAddressFamiliyNotSupported -> "Tcp address family not supported"
  if err == PlatformError.TcpConnectionRefused          -> "Tcp connection refused"
  if err == PlatformError.TcpTimeout                    -> "Tcp timeout occured"
  if err == PlatformError.TcpAddressNotFound            -> "Tcp address not found"
  if err == PlatformError.TcpRemoteResetConnection      -> "Tcp connection reset by remote"
  if err == PlatformError.TcpSocketIsDead               -> "Tcp socket is dead"
  if err == PlatformError.SleepFailed                   -> "Sleep failed"
  else                                                  -> "Unrecognized platform error '" + int(err) + "'"

// -- Platform

act getPlatform() Platform(intrinsic{runtime_platform}())

act getPlatformErrorCode() PlatformError(intrinsic{platform_error_code}())

act getPlatformError(string message = "")
  code = getPlatformErrorCode();
  Error(code, message.isEmpty() ? code.string() : message + ": " + code.string())

// -- Versions

act getRuntimeVersion() -> Version
  versionParser().run(intrinsic{version_runtime}()).failOnError()

act getCompilerVersion() -> Version
  versionParser().run(intrinsic{version_compiler}()).failOnError()

// -- Paths

act getPathCurrent() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_workingdirectory}()).failOnError()

act getPathRuntime() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_runtime}()).failOnError()

act getPathProgram() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_program}()).failOnError()

// -- Interupt

act interuptIsRequested() -> bool
  intrinsic{interupt_isrequested}()

act interuptReset() -> bool
  intrinsic{interupt_reset}()

act atInterupt{T}(action{T} delegate) -> future{T}
  fork invoke(impure lambda () -> T
    if interuptIsRequested() -> delegate()
    else                     -> sleep(milliseconds(100)); self())

// -- Misc

act sleep(Duration d) -> Option{Error}
  intrinsic{sleep_nano}(d.ns) ? None() : getPlatformError()

// -- Failure

act fail(string msg) -> Option{Error}
  fail{Option{Error}}(msg)

act fail(Error err) -> Option{Error}
  fail{Option{Error}}(err)

act fail{TResult}(string msg) -> TResult
  printErr(msg);
  intrinsic{fail}{TResult}()

act fail{TResult}(Error err) -> TResult
  writer = litWriter("Failed:\n") & errorWriter(litWriter("- "), newlineWriter());
  fail{TResult}(writer.run(err))

act failOnError{T}(Either{T, Error} v) -> T
  if v as T      val -> val
  if v as Error  err -> fail{T}(err)

act failOnError(Option{Error} v) -> None
  if v as Error  err -> fail{None}(err)
  else               -> None()

// -- Tests

assert(
  p = getPlatform();
  p == Platform.Linux || p == Platform.MacOs || p == Platform.Windows)

assert(getRuntimeVersion() >= Version(0, 5, 0))

assert(getCompilerVersion() >= Version(0, 5, 0))

assert(getPathCurrent().extension() is None)

assert(
  runtimeName = getPathRuntime().stem();
  runtimeName == "novrt" || runtimeName == "nove")

assert(getPathProgram().filename() == "rt.nov")

assert(getPathProgram().stem() == "rt")

assert(getPathProgram().extension() == "nov")
