import "std/console.nov"
import "std/path.nov"
import "std/time.nov"
import "std/version.nov"

// -- Types

enum Platform =
  Linux   : 1,
  MacOs   : 2,
  Windows : 3

enum PlatformError =
  Unknown                       : 001,
  FeatureNetworkNotEnabled      : 100,
  StreamOptionsNotSupported     : 200,
  TcpUknownError                : 300,
  TcpInvalidSocket              : 301,
  TcpInvalidConnectionSocket    : 302,
  TcpInvalidServerSocket        : 303,
  TcpAlreadyInProcess           : 304,
  TcpNetworkDown                : 305,
  TcpSocketCouldNotBeAllocated  : 306,
  TcpInvalidPort                : 307,
  TcpInvalidBacklog             : 308,
  TcpInvalidAddressFamily       : 309,
  TcpNoAccess                   : 310,
  TcpAddressInUse               : 311,
  TcpAddressUnavailable         : 312,
  TcpInvalidAddress             : 313,
  TcpNetworkUnreachable         : 314,
  TcpAddressFamiliyNotSupported : 315,
  TcpConnectionRefused          : 316,
  TcpTimeout                    : 317,
  TcpAddressNotFound            : 318,
  TcpRemoteResetConnection      : 319,
  TcpSocketIsDead               : 320

// -- Conversions

fun string(Platform p)
  if p == Platform.Linux    -> "Linux"
  if p == Platform.MacOs    -> "MacOs"
  if p == Platform.Windows  -> "Windows"
  else                      -> "Unknown"

fun string(PlatformError err)
  if err == PlatformError.Unknown                       -> "Unknown"
  if err == PlatformError.FeatureNetworkNotEnabled      -> "Network feature not enabled"
  if err == PlatformError.StreamOptionsNotSupported     -> "Stream does not support the given options"
  if err == PlatformError.TcpUknownError                -> "Uknown Tcp error occured"
  if err == PlatformError.TcpInvalidSocket              -> "Invalid Tcp socket"
  if err == PlatformError.TcpInvalidConnectionSocket    -> "Invalid Tcp connection socket"
  if err == PlatformError.TcpInvalidServerSocket        -> "Invalid Tcp server socket"
  if err == PlatformError.TcpAlreadyInProcess           -> "Tcp operation already in progess"
  if err == PlatformError.TcpNetworkDown                -> "Tcp network down"
  if err == PlatformError.TcpSocketCouldNotBeAllocated  -> "New Tcp socket could not be allocated"
  if err == PlatformError.TcpInvalidPort                -> "Invalid Tcp port"
  if err == PlatformError.TcpInvalidBacklog             -> "Invalid Tcp backlog"
  if err == PlatformError.TcpInvalidAddressFamily       -> "Invalid Tcp address-family"
  if err == PlatformError.TcpNoAccess                   -> "Tcp access denied"
  if err == PlatformError.TcpAddressInUse               -> "Tcp address already in use"
  if err == PlatformError.TcpAddressUnavailable         -> "Tcp address cannot be assigned"
  if err == PlatformError.TcpInvalidAddress             -> "Invalid Tcp address"
  if err == PlatformError.TcpNetworkUnreachable         -> "Tcp network unreachable"
  if err == PlatformError.TcpAddressFamiliyNotSupported -> "Tcp address family not supported"
  if err == PlatformError.TcpConnectionRefused          -> "Tcp connection refused"
  if err == PlatformError.TcpTimeout                    -> "Tcp timeout occured"
  if err == PlatformError.TcpAddressNotFound            -> "Tcp address not found"
  if err == PlatformError.TcpRemoteResetConnection      -> "Tcp connection reset by remote"
  if err == PlatformError.TcpSocketIsDead               -> "Tcp socket is dead"
  else                                                  -> "Unrecognized platform error '" + int(err) + "'"

// -- Platform

act getPlatform() Platform(intrinsic{runtime_platform}())

act getPlatformErrorCode() PlatformError(intrinsic{platform_error_code}())

act getPlatformError() Error(getPlatformErrorCode(), getPlatformErrorCode().string())

// -- Versions

act getRuntimeVersion() -> Version
  versionParser().run(intrinsic{version_runtime}()).failOnError()

act getCompilerVersion() -> Version
  versionParser().run(intrinsic{version_compiler}()).failOnError()

// -- Paths

act getPathCurrent() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_workingdirectory}()).failOnError()

act getPathRuntime() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_runtime}()).failOnError()

act getPathProgram() -> PathAbsolute
  pathAbsParser().run(intrinsic{path_program}()).failOnError()

// -- Interupt

act interuptIsRequested() -> bool
  intrinsic{interupt_isrequested}()

act interuptReset() -> bool
  intrinsic{interupt_reset}()

act atInterupt{T}(action{T} delegate) -> future{T}
  fork invoke(impure lambda () -> T
    if interuptIsRequested() -> delegate()
    else                     -> sleep(milliseconds(100)); self())

// -- Misc

act sleep(Duration d) -> Option{Error}
  intrinsic{sleep_nano}(d.ns); None()

// -- Failure

act fail(string msg) -> Option{Error}
  fail{Option{Error}}(msg)

act fail(Error err) -> Option{Error}
  fail{Option{Error}}(err)

act fail{TResult}(string msg) -> TResult
  printErr(msg);
  intrinsic{fail}{TResult}()

act fail{TResult}(Error err) -> TResult
  writer = litWriter("Failed:\n") & errorWriter(litWriter("- "), newlineWriter());
  fail{TResult}(writer.run(err))

act failOnError{T}(Either{T, Error} v) -> T
  if v as T      val -> val
  if v as Error  err -> fail{T}(err)

act failOnError(Option{Error} v) -> None
  if v as Error  err -> fail{None}(err)
  else               -> None()

// -- Tests

assert(
  p = getPlatform();
  p == Platform.Linux || p == Platform.MacOs || p == Platform.Windows)

assert(getRuntimeVersion() >= Version(0, 5, 0))

assert(getCompilerVersion() >= Version(0, 5, 0))

assert(getPathCurrent().extension() is None)

assert(
  runtimeName = getPathRuntime().stem();
  runtimeName == "novrt" || runtimeName == "nove")

assert(getPathProgram().filename() == "rt.nov")

assert(getPathProgram().stem() == "rt")

assert(getPathProgram().extension() == "nov")
