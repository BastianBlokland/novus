import "std/parser.nov"
import "std/text.nov"
import "std/writer.nov"

// -- Types

enum Endianness =
  Little  : 0,
  Big     : 1

// -- Conversions

fun string(Endianness e)
  if e == Endianness.Little -> "LittleEndian"
  if e == Endianness.Big    -> "BigEndian"
  else                      -> "Unknown"

// -- Utilities

// Unset the least significant set bit.
fun unsetLow(int mask)
  mask & mask - 1

// Clears all but the least significant set bit.
fun onlyLow(int mask)
  mask & ~mask + 1

// Unset the most significant set bit.
fun unsetHigh(int mask)
  m1 = mask | mask >> 1;
  m2 = m1   | m1   >> 2;
  m3 = m2   | m2   >> 4;
  m4 = m3   | m3   >> 8;
  m5 = m4   | m4   >> 16;
  mask & m5 >> 1

// Count how many bits are set.
fun popCount(int mask)
  f = ( lambda (int mask, int num)
    if mask == 0  -> num
    else          -> self(unsetLow(mask), ++num)
  ); f(mask, 0)

// Count the trailing zeroes.
fun trailingZeroes(int mask)
  if mask == 0  -> 32
  else          ->
    f = ( lambda (int mask, int num)
      if mask == 0 || (mask & 1) != 0 -> num
      else                            -> self(mask >> 1, ++num)
    ); f(mask, 0)

// Count the leading zeroes.
fun leadingZeroes(int mask)
  if mask == 0  -> 32
  else          ->
    f = ( lambda (int mask, int num)
      if mask < 0 -> num
      else        -> self(mask << 1, ++num)
    ); f(mask, 0)

// Returns a new mask with only the Nth least significant set bit still set.
// Examples:
// * Mask 10010100 bit 0 = 00000100
// * Mask 10010100 bit 1 = 00010000
// * Mask 10010100 bit 2 = 10000000
fun nthSetBit(int mask, int bit)
  f = (lambda (int mask, int i)
    if i >= bit -> onlyLow(mask)
    else        -> self(unsetLow(mask), ++i)
  ); f(mask, 0)

// Convert the mask into a binary string with characters '0' and '1'.
fun toBitString(int mask, bool includeLeadingZeroes)
  if mask == 0  -> string('0', includeLeadingZeroes ? 32 : 1)
  else          ->
    f = ( lambda (int idx, string result)
      if idx < 0  -> result
      else        -> self(--idx, result + ((mask & 1 << idx) == 0 ? '0' : '1'))
    ); f(includeLeadingZeroes ? 31 : 31 - leadingZeroes(mask), "")

// Convert the mask into a hexadecimal string with characters '0'-'9' and 'A'-'F'.
fun toHexString(int mask)
  if mask == 0  -> "0"
  else          ->
    f = ( lambda (int mask, string result)
      if mask == 0  -> result
      else          -> self(
        mask >> 4,
        v = mask & 0xF;
        string(v < 10 ? char('0' + v) : char('A' + v - 10)) + result)
    ); f(mask, "")

fun signExtend16To32(int val)
  (0xffff & val ^ 0x8000) - 0x8000

fun parseInt16(Endianness en, char a, char b) -> int
  if en == Endianness.Little -> (int(a) << 0) | (int(b) << 8)
  else                       -> (int(a) << 8) | (int(b) << 0)

fun parseSInt16(Endianness en, char a, char b) -> int
  if en == Endianness.Little -> signExtend16To32((int(a) << 0) | (int(b) << 8))
  else                       -> signExtend16To32((int(a) << 8) | (int(b) << 0))

fun parseInt32(Endianness en, char a, char b, char c, char d) -> int
  if en == Endianness.Little -> (int(a) << 0)  | (int(b) << 8)  | (int(c) << 16) | (int(d) << 24)
  else                       -> (int(a) << 24) | (int(b) << 16) | (int(c) << 8)  | (int(d) << 0)

fun parseInt64(Endianness en, char a, char b, char c, char d, char e, char f, char g, char h) -> long
  if en == Endianness.Little ->
    (long(a) << 0)  | (long(b) << 8)  | (long(c) << 16) | (long(d) << 24) |
    (long(e) << 32) | (long(f) << 40) | (long(g) << 48) | (long(h) << 56)
  else                       ->
    (long(a) << 56) | (long(b) << 48) | (long(c) << 40) | (long(d) << 32) |
    (long(e) << 24) | (long(f) << 16) | (long(g) << 8)  | (long(h) << 0)

// -- Parsers

fun bitInt8Parser() -> Parser{char}
  charParser()

fun bitInt16Parser(Endianness e) -> Parser{int}
  takeParser(2).map(lambda (string s) parseInt16(e, s[0], s[1]))

fun bitSInt16Parser(Endianness e) -> Parser{int}
  takeParser(2).map(lambda (string s) parseSInt16(e, s[0], s[1]))

fun bitInt32Parser(Endianness e) -> Parser{int}
  takeParser(4).map(lambda (string s) parseInt32(e, s[0], s[1], s[2], s[3]))

fun bitInt64Parser(Endianness e) -> Parser{long}
  takeParser(8).map(lambda (string s) parseInt64(e, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]))

// -- Writers

fun bitInt8Writer() -> Writer{char}
  charWriter()

fun bitInt16Writer(Endianness e) -> Writer{int}
  Writer(lambda (WriterState s, int i)
    if e == Endianness.Little ->
      s.write(char(i >> 0) + char(i >> 8))
    else                      ->
      s.write(char(i >> 8) + char(i >> 0))
  )

fun bitInt32Writer(Endianness e) -> Writer{int}
  Writer(lambda (WriterState s, int i)
    if e == Endianness.Little ->
      s.write(char(i >> 0) + char(i >> 8) + char(i >> 16) + char(i >> 24))
    else                      ->
      s.write(char(i >> 24) + char(i >> 16) + char(i >> 8) + char(i >> 0))
  )

fun bitInt64Writer(Endianness e) -> Writer{long}
  Writer(lambda (WriterState s, long l)
    if e == Endianness.Little ->
      s.write(
        char(l >> 0)  + char(l >> 8)  + char(l >> 16) + char(l >> 24) +
        char(l >> 32) + char(l >> 40) + char(l >> 48) + char(l >> 56))
    else                      ->
      s.write(
        char(l >> 56) + char(l >> 48) + char(l >> 40) + char(l >> 32) +
        char(l >> 24) + char(l >> 16) + char(l >> 8)  + char(l >> 0))
  )

// -- Actions

act endiannessNative() Endianness(endiannessNativeCode())

// -- Tests

assert(
  unsetLow(0b111) == 0b110 &&
  unsetLow(0b110) == 0b100 &&
  unsetLow(0b11000000) == 0b10000000 &&
  unsetLow(0) == 0 &&
  unsetLow(1) == 0)

assert(
  onlyLow(0) == 0 &&
  onlyLow(1) == 1 &&
  onlyLow(-1) == 1 &&
  onlyLow(0b100) == 0b100 &&
  onlyLow(0b1010_1000) == 0b1000)

assert(
  unsetHigh(0) == 0 &&
  unsetHigh(1) == 0 &&
  unsetHigh(0b11) == 0b1 &&
  unsetHigh(0b1101) == 0b101 &&
  unsetHigh(0b1101001) == 0b101001 &&
  unsetHigh(0b1001101001) == 0b1101001 &&
  unsetHigh(-1) == -1 >> 1 &&
  unsetHigh(0b1000_0000_0000_0000_0000_0000_0100_1000) == 0b100_1000)

assert(
  popCount(0) == 0 &&
  popCount(1) == 1 &&
  popCount(0b0010) == 1 &&
  popCount(0b101) == 2 &&
  popCount(0b100101) == 3 &&
  popCount(0xFFFF_FFFF) == 32 &&
  popCount(0xEFFF_FFFF) == 31)

assert(
  trailingZeroes(0) == 32 &&
  trailingZeroes(-1) == 0 &&
  trailingZeroes(0b10) == 1 &&
  trailingZeroes(0b10100) == 2 &&
  trailingZeroes(0b101001000) == 3)

assert(
  leadingZeroes(0) == 32 &&
  leadingZeroes(-1) == 0 &&
  leadingZeroes(1) == 31 &&
  leadingZeroes(1 << 30) == 1 &&
  leadingZeroes(1 << 15) == 16 &&
  leadingZeroes(0b0000_0100_0101_0101_0110_0101_0100_1000) == 5 &&
  leadingZeroes(-1) == 0)

assert(
  nthSetBit(0, -1) == 0 &&
  nthSetBit(0, 0) == 0 &&
  nthSetBit(0, 1) == 0 &&
  nthSetBit(0b1, 0) == 1 &&
  nthSetBit(0b1, 1) == 0 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 0) == 1 &&
  nthSetBit(0b1001_1101, 2) == 0b1000 &&
  nthSetBit(0b1001_1101, 4) == 0b1000_0000)

assert(
  toBitString(0, false) == "0" &&
  toBitString(0, true) == string('0', 32) &&
  toBitString(-1, false) == string('1', 32) &&
  toBitString(-1, true) == string('1', 32) &&
  toBitString(1, false) == "1" &&
  toBitString(2, false) == "10" &&
  toBitString(4, false) == "100" &&
  toBitString(0b1011_1101_1111, false) == "101111011111" &&
  toBitString(0b0000_0100_0101_0101_0110_0101_0100_1000, true) == "00000100010101010110010101001000")

assert(
  toHexString(0) == "0" &&
  toHexString(-1) == "FFFFFFFF" &&
  toHexString(1) == "1" &&
  toHexString(0x1A2B3C) == "1A2B3C" &&
  toHexString(0xABCDEF) == "ABCDEF" &&
  toHexString(0x123ABC) == "123ABC")

assert(bitInt8Writer()('a') == "a")

assert(
  w = bitInt8Writer();
  p = bitInt8Parser();
  p(w(char(0)).string())    == char(0)    &&
  p(w(char(1)).string())    == char(1)    &&
  p(w(char(-1)).string())   == char(-1)   &&
  p(w(char(42)).string())   == char(42)   &&
  p(w(char(-42)).string())  == char(-42)  &&
  p(w(char(240)).string())  == char(240)  &&
  p(w(char(256)).string())  == char(256))

assert(
  w = bitInt16Writer(Endianness.Little);
  p = bitSInt16Parser(Endianness.Little);
  w(1337)                 == char(57) + char(5) &&
  p(w(0).string())        == 0                  &&
  p(w(1).string())        == 1                  &&
  p(w(-1).string())       == -1                 &&
  p(w(42).string())       == 42                 &&
  p(w(-42).string())      == -42                &&
  p(w(1337).string())     == 1337               &&
  p(w(-1337).string())    == -1337              &&
  p(w(32_767).string())   == 32_767             &&
  p(w(-32_768).string())  == -32_768)

assert(
  w = bitInt16Writer(Endianness.Big);
  p = bitSInt16Parser(Endianness.Big);
  w(1337)                 == char(5) + char(57) &&
  p(w(0).string())        == 0                  &&
  p(w(1).string())        == 1                  &&
  p(w(-1).string())       == -1                 &&
  p(w(42).string())       == 42                 &&
  p(w(-42).string())      == -42                &&
  p(w(1337).string())     == 1337               &&
  p(w(-1337).string())    == -1337              &&
  p(w(32_767).string())   == 32_767             &&
  p(w(-32_768).string())  == -32_768)

assert(
  w = bitInt32Writer(Endianness.Little);
  p = bitInt32Parser(Endianness.Little);
  w(13371337)             == char(201) + char(7) + char(204) + char(0)  &&
  p(w(0).string())        == 0                                          &&
  p(w(1).string())        == 1                                          &&
  p(w(-1).string())       == -1                                         &&
  p(w(42).string())       == 42                                         &&
  p(w(-42).string())      == -42                                        &&
  p(w(1337).string())     == 1337                                       &&
  p(w(-1337).string())    == -1337                                      &&
  p(w(32_767).string())   == 32_767                                     &&
  p(w(-32_768).string())  == -32_768                                    &&
  p(w(100_000).string())  == 100_000                                    &&
  p(w(-100_000).string()) == -100_000                                   &&
  p(w(intMax()).string()) == intMax()                                   &&
  p(w(intMin()).string()) == intMin())

assert(
  w = bitInt32Writer(Endianness.Big);
  p = bitInt32Parser(Endianness.Big);
  w(13371337)             == char(0) + char(204) + char(7) + char(201)  &&
  p(w(0).string())        == 0                                          &&
  p(w(1).string())        == 1                                          &&
  p(w(-1).string())       == -1                                         &&
  p(w(42).string())       == 42                                         &&
  p(w(-42).string())      == -42                                        &&
  p(w(1337).string())     == 1337                                       &&
  p(w(-1337).string())    == -1337                                      &&
  p(w(32_767).string())   == 32_767                                     &&
  p(w(-32_768).string())  == -32_768                                    &&
  p(w(100_000).string())  == 100_000                                    &&
  p(w(-100_000).string()) == -100_000                                   &&
  p(w(intMax()).string()) == intMax()                                   &&
  p(w(intMin()).string()) == intMin())

assert(
  w = bitInt64Writer(Endianness.Little);
  p = bitInt64Parser(Endianness.Little);
  w(1337133713371337L)                        ==
    char(201) + char(176) + char(0) + char(180) + char(29) + char(192) + char(4) + char(0) &&
  p(w(0L).string())                           == 0L                                        &&
  p(w(1L).string())                           == 1L                                        &&
  p(w(-1L).string())                          == -1L                                       &&
  p(w(42L).string())                          == 42L                                       &&
  p(w(-42L).string())                         == -42L                                      &&
  p(w(1337L).string())                        == 1337L                                     &&
  p(w(-1337L).string())                       == -1337L                                    &&
  p(w(32_767L).string())                      == 32_767L                                   &&
  p(w(-32_768L).string())                     == -32_768L                                  &&
  p(w(100_000L).string())                     == 100_000L                                  &&
  p(w(-100_000L).string())                    == -100_000L                                 &&
  p(w(2_147_483_647L).string())               == 2_147_483_647L                            &&
  p(w(-2_147_483_648L).string())              == -2_147_483_648L                           &&
  p(w(9_223_372_036_854_775_807L).string())   == 9_223_372_036_854_775_807L                &&
  p(w(longMin()).string())                    == longMin() )

assert(
  w = bitInt64Writer(Endianness.Big);
  p = bitInt64Parser(Endianness.Big);
  w(1337133713371337L)                        ==
    char(0) + char(4) + char(192) + char(29) + char(180) + char(0) + char(176) + char(201)  &&
  p(w(0L).string())                           == 0L                                         &&
  p(w(1L).string())                           == 1L                                         &&
  p(w(-1L).string())                          == -1L                                        &&
  p(w(42L).string())                          == 42L                                        &&
  p(w(-42L).string())                         == -42L                                       &&
  p(w(1337L).string())                        == 1337L                                      &&
  p(w(-1337L).string())                       == -1337L                                     &&
  p(w(32_767L).string())                      == 32_767L                                    &&
  p(w(-32_768L).string())                     == -32_768L                                   &&
  p(w(100_000L).string())                     == 100_000L                                   &&
  p(w(-100_000L).string())                    == -100_000L                                  &&
  p(w(2_147_483_647L).string())               == 2_147_483_647L                             &&
  p(w(-2_147_483_648L).string())              == -2_147_483_648L                            &&
  p(w(9_223_372_036_854_775_807L).string())   == 9_223_372_036_854_775_807L                 &&
  p(w(longMin()).string())                    == longMin() )

// This test is left here for the first person running this on a BigEndian system, needs thorough
// testing as none of this code has ever been run on a BigEndian system.
assert(endiannessNative() == Endianness.Little)
