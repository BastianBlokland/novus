import "ascii.nov"
import "text.nov"
import "math.nov"
import "pair.nov"
import "either.nov"
import "error.nov"

// -- Types

struct  ParseState      = string str, int pos
struct  ParseSuccess{T} = T val, ParseState state
struct  ParseFailure    = Error err, ParseState state
union   ParseResult{T}  = ParseSuccess{T}, ParseFailure
struct  Parser{T}       = function{ParseState, ParseResult{T}} func

// -- Operators

fun ??{T}(ParseResult{T} res, T def)
  res as ParseSuccess{T} suc ? suc.val : def

fun ??{T1, T2}(ParseResult{T1} res, T2 def) -> Either{T1, T2}
  res as ParseSuccess{T1} suc ? suc.val : def

fun ==(ParseState s, char c)
  s.str[s.pos] == c

fun ==(ParseState s, string text)
  startsWithOffset(s.str, s.pos, text)

fun +(ParseState s, int amount)
  ParseState(s.str, s.pos + amount)

fun ++(ParseState s)
  s + 1

fun &{T1, T2}(Parser{T1} p1, Parser{T2} p2)
  Parser(lambda (ParseState s) -> ParseResult{Pair{T1, T2}}
    r1 = s.parse(p1);
    if r1 as ParseFailure     f1 -> f1
    if r1 as ParseSuccess{T1} s1 ->
      r2 = s1.state.parse(p2);
      if r2 as ParseFailure     f2 -> f2
      if r2 as ParseSuccess{T2} s2 -> s2.state.success(Pair(s1.val, s2.val))
  )

fun |{T}(Parser{T} p1, Parser{T} p2)
  Parser(lambda (ParseState s) -> ParseResult{T}
    r1 = s.parse(p1);
    if r1 is ParseSuccess{T} -> r1
    if r1 is ParseFailure    -> s.parse(p2)
  )

fun |{T1, T2}(Parser{T1} p1, Parser{T2} p2)
  Parser(lambda (ParseState s) -> ParseResult{Either{T1, T2}}
    r1 = s.parse(p1);
    if r1 as ParseSuccess{T1} s1 -> s1.state.success(                 Either{T1, T2}(s1.val))
    if r1 is ParseFailure        -> s.parse(p2).map(lambda (T2 val2)  Either{T1, T2}(val2))
  )

fun >>{T1, T2}(Parser{T1} p1, Parser{T2} p2)
  Parser(lambda (ParseState s) -> ParseResult{T2}
    r1 = s.parse(p1);
    if r1 as ParseFailure     f1 -> f1
    if r1 as ParseSuccess{T1} c1 -> c1.state.parse(p2)
  )

fun <<{T1, T2}(Parser{T1} p1, Parser{T2} p2)
  Parser(lambda (ParseState s) -> ParseResult{T1}
    r1 = s.parse(p1);
    if r1 as ParseFailure     f1 -> f1
    if r1 as ParseSuccess{T1} s1 ->
      r2 = s1.state.parse(p2);
      if r2 as ParseFailure     f2 -> f2
      if r2 as ParseSuccess{T2} s2 -> s2.state.success(s1.val)
  )

fun =={T}(ParseResult{T} result, T val)
  result as ParseSuccess{T} suc && suc.val == val

fun =={T1, T2}(ParseResult{Either{T1, T2}} result, T1 val)
  result as ParseSuccess{Either{T1, T2}} suc && suc.val == val

fun =={T1, T2}(ParseResult{Either{T1, T2}} result, T2 val)
  result as ParseSuccess{Either{T1, T2}} suc && suc.val == val

// -- Conversions

fun string(ParseState s)
  s.pos.string()

fun string{T}(ParseResult{T} res)
  if res as ParseSuccess{T} suc   -> suc.val.string()
  if res as ParseFailure    fail  -> fail.err.string()

fun char(ParseState s)
  s.str[s.pos]

// -- Utilities

fun parse{T}(string str, Parser{T} p)     ParseState(str, 0).parse(p)
fun parse{T}(ParseState s, Parser{T} p)   p.func(s)

fun isEnd(ParseState s)                   s.pos >= s.str.length()

fun success{T}(ParseState s, T val)       ParseSuccess(val, s)
fun failure(ParseState s, Error err)      ParseFailure(err, s)

fun map{T, TResult}(ParseResult{T} res, function{T, TResult} func)
  if res as ParseSuccess{T} suc   -> suc.state.success(func(suc.val))
  if res as ParseFailure    fail  -> fail

// -- Basic parsers

fun retParser{T}(T val)
  Parser(lambda (ParseState s) -> ParseResult{T}
    s.success(val)
  )

fun matchParser(char c)
  Parser(lambda (ParseState s) -> ParseResult{char}
    if s == c -> (s + 1).success(c)
    else      -> s.failure(Error("Unmatched: '" + c + "'"))
  )

fun matchParser(string str)
  Parser(lambda (ParseState s) -> ParseResult{string}
    if s == str -> (s + str.length()).success(str)
    else        -> s.failure(Error("Unmatched: '" + str + "'"))
  )

fun txtBoolParser()
  Parser(lambda (ParseState s) -> ParseResult{bool}
    if s == "true"  -> (s + 4).success(true)
    if s == "TRUE"  -> (s + 4).success(true)
    if s == "True"  -> (s + 4).success(true)
    if s == "false" -> (s + 5).success(false)
    if s == "FALSE" -> (s + 5).success(false)
    if s == "False" -> (s + 5).success(false)
    else            -> s.failure(Error("Invalid boolean"))
  )

fun txtIntParser()
  Parser(lambda (ParseState s)
    impl =
    (
      lambda (ParseState s, int res, bool valid) -> ParseResult{int}
        if char(s).isDigit()  -> self(++s, res * 10 + char(s) - '0', true)
        else                  -> valid ?  s.success(res) :
                                          s.failure(Error("Invalid integer"))
    );
    if s.isEnd() -> s.failure(Error("Unexpected end of input"))
    if s == '-'  -> impl(++s, 0, false).map(negate{int})
    if s == '+'  -> impl(++s, 0, false)
    else         -> impl(s, 0, false)
  )

fun txtFloatParser()
  Parser(lambda (ParseState s)
    impl =
    (
      lambda (ParseState s, float raw, float div, bool dec, bool valid) -> ParseResult{float}
        if s == '.' && !dec     -> self(++s, raw, div, true, false)
        if char(s).isDigit()    -> newRaw = raw * 10.0 + int(char(s)) - int('0');
                                   newDiv = dec ? div * 10.0 : div;
                                   self(++s, newRaw, newDiv, dec, true)
        if s == 'e' || s == 'E' -> (s + 1).parse(txtIntParser()).map(lambda (int exp)
                                                                      raw / (div / pow(10.0, exp)))
        else                    -> valid ?  s.success(raw / div) :
                                            s.failure(Error("Invalid floating-point number"))
    );
    if s.isEnd() -> s.failure(Error("Unexpected end of input"))
    if s == '-'  -> impl(++s, 0.0, 1.0, false, false).map(negate{float})
    if s == '+'  -> impl(++s, 0.0, 1.0, false, false)
    else         -> impl(s,   0.0, 1.0, false, false)
  )

// -- Tests

assert("".parse(retParser(42)) == 42)

assert(
  "a".parse(matchParser('a')) == 'a' &&
  "b".parse(matchParser('a')) is ParseFailure)

assert(
  "hello world".parse(matchParser("hello")) == "hello" &&
  "world".parse(matchParser("hello")) is ParseFailure)

assert(
  "1".parse(txtIntParser())                == 1 &&
  "-1".parse(txtIntParser())               == -1 &&
  "+1".parse(txtIntParser())               == 1 &&
  "1337".parse(txtIntParser())             == 1337 &&
  intMax().string().parse(txtIntParser())  == intMax() &&
  intMin().string().parse(txtIntParser())  == intMin() &&
  "2147483648".parse(txtIntParser())       == -2147483647 - 1)

assert(
  "".parse(txtIntParser())         is ParseFailure &&
  "a".parse(txtIntParser())        is ParseFailure &&
  " 123".parse(txtIntParser())     is ParseFailure)

assert(
  "0".parse(txtFloatParser())            == 0.0 &&
  "1".parse(txtFloatParser())            == 1.0 &&
  "0001".parse(txtFloatParser())         == 1.0 &&
  "0e10".parse(txtFloatParser())         == 0.0 &&
  "0e-10".parse(txtFloatParser())        == 0.0 &&
  "-1".parse(txtFloatParser())           == -1.0 &&
  "+1".parse(txtFloatParser())           == 1.0 &&
  "-1.1".parse(txtFloatParser())         == -1.1 &&
  "+1.1".parse(txtFloatParser())         == 1.1 &&
  "-.1".parse(txtFloatParser())          == -0.1 &&
  "+.1".parse(txtFloatParser())          == 0.1 &&
  "42e0".parse(txtFloatParser())         == 42.0 &&
  "42e1".parse(txtFloatParser())         == 420.0 &&
  "42e2".parse(txtFloatParser())         == 4200.0 &&
  "42e+0".parse(txtFloatParser())        == 42.0 &&
  "42e+1".parse(txtFloatParser())        == 420.0 &&
  "42e+2".parse(txtFloatParser())        == 4200.0 &&
  "42e-0".parse(txtFloatParser())        == 42.0 &&
  "42e-1".parse(txtFloatParser())        == 4.2 &&
  "42e-2".parse(txtFloatParser())        == .42 &&
  "42.1337".parse(txtFloatParser())      == 42.1337 &&
  "42.1337e4".parse(txtFloatParser())    == 421337.0 &&
  "+42.1337E-2".parse(txtFloatParser())  == .421337 &&
  "-42.1337E-2".parse(txtFloatParser())  == -.421337 &&
  ("4000000000".parse(txtFloatParser()) ?? -1.0).approx(4000000000.0))

assert(
  "".parse(txtFloatParser())       is ParseFailure &&
  "--1".parse(txtFloatParser())    is ParseFailure &&
  "-+1".parse(txtFloatParser())    is ParseFailure &&
  " 1.0".parse(txtFloatParser())   is ParseFailure &&
  "1. 0 ".parse(txtFloatParser())  is ParseFailure)

assert(
  "true".parse(txtBoolParser())  == true &&
  "TRUE".parse(txtBoolParser())  == true &&
  "True".parse(txtBoolParser())  == true &&
  "false".parse(txtBoolParser()) == false &&
  "FALSE".parse(txtBoolParser()) == false &&
  "False".parse(txtBoolParser()) == false)

assert(
  "".parse(txtBoolParser())      is ParseFailure &&
  "tRuE".parse(txtBoolParser())  is ParseFailure &&
  "fAlSe".parse(txtBoolParser()) is ParseFailure &&
  "abc".parse(txtBoolParser())   is ParseFailure)

assert(
  p = (matchParser("Hello ") | matchParser("Greetings ")) & matchParser("World");
  "Hello World".parse(p) == Pair("Hello ", "World") &&
  "Greetings World".parse(p) == Pair("Greetings ", "World") &&
  "HelloWorld".parse(p) is ParseFailure)

assert(
  p = txtBoolParser() | txtIntParser();
  "42".parse(p)   == 42 &&
  "true".parse(p) == true &&
  "hello".parse(p) is ParseFailure)

assert(
  p = matchParser("Hello ") >> matchParser("World");
  "Hello World".parse(p) == "World" &&
  "Hello ".parse(p) is ParseFailure &&
  "World".parse(p) is ParseFailure &&
  "abc".parse(p) is ParseFailure)

assert(
  p = matchParser("Hello") << matchParser(" World");
  "Hello World".parse(p) == "Hello" &&
  "Hello".parse(p) is ParseFailure &&
  " World".parse(p) is ParseFailure &&
  "abc".parse(p) is ParseFailure)
