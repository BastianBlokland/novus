import "std/bits.nov"
import "std/error.nov"
import "std/parser.nov"
import "std/stream.nov"

// -- Types

struct Console =
  sys_stream  stdIn,
  sys_stream  stdOut,
  sys_stream  stdErr

// -- Actions

act consoleOpen() -> Either{Console, Error}
  stdIn   = intrinsic{console_openstream}(0);
  stdOut  = intrinsic{console_openstream}(1);
  stdErr  = intrinsic{console_openstream}(2);
  if stdIn.isValid() && stdOut.isValid() && stdErr.isValid() ->
    Console(stdIn, stdOut, stdErr)
  else ->
    Error("Failed to open console")

act setNoBlockInput(Console c) -> Option{Error}
  c.stdIn.setOptions(StreamOptions.NoBlock)

act unsetNoBlockInput(Console c) -> Option{Error}
  c.stdIn.unsetOptions(StreamOptions.NoBlock)

act read(Console c) -> Either{char, Error}
  c.stdIn.read()

act readLine(Console c) -> Either{string, Error}
  c.stdIn.readLine()

act readToEnd(Console c) -> Either{string, Error}
  c.stdIn.readToEnd()

act readToEnd{T}(Console c, Parser{T} parser) -> Either{T, Error}
  c.readToEnd().map(impure lambda (string s) parser.run(s))

act read() -> Either{char, Error}
  consoleOpen().map(impure lambda (Console c) c.read())

act readLine() -> Either{string, Error}
  consoleOpen().map(impure lambda (Console c) c.readLine())

act writeOut(Console c, string str) -> Option{Error}
  c.stdOut.write(str)

act writeOut(Console c, char ch) -> Option{Error}
  c.stdOut.write(ch)

act writeOut{T}(Console c, Writer{T} writer, T val) -> Option{Error}
  c.write(writer.run(val))

act writeErr(Console c, string str) -> Option{Error}
  c.stdErr.write(str)

act writeErr(Console c, char ch) -> Option{Error}
  c.stdErr.write(ch)

act writeErr{T}(Console c, Writer{T} writer, T val) -> Option{Error}
  c.write(writer.run(val))

act flushOut(Console c) -> Option{Error}
  c.stdOut.flush()

act flushErr(Console c) -> Option{Error}
  c.stdErr.flush()

act print{T}(T x) -> Option{Error}
  consoleOpen().map(impure lambda (Console c) -> Option{Error}
    actSeq(
      lazy c.stdOut.write(x.string() + '\n'),
      lazy c.stdOut.flush()
    )
  )

act printErr{T}(T x) -> Option{Error}
  consoleOpen().map(impure lambda (Console c) -> Option{Error}
    actSeq(
      lazy c.stdErr.write(x.string() + '\n'),
      lazy c.stdErr.flush()
    )
  )

act printBits(int i) -> Option{Error}
  print(toBitString(i, false))

act printBits(float f) -> Option{Error}
  print(toBitString(asInt(f), false))

act printHex(int i) -> Option{Error}
  print(toHexString(i))

act printHex(float f) -> Option{Error}
  print(toHexString(asInt(f)))
