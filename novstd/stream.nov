import "std/pair.nov"
import "std/list.nov"
import "std/text.nov"

// -- Types

enum StreamOptions =
  NoBlock : 0b1

struct StreamReadState =
  string      txt,
  bool        reachedEnd,
  sys_stream  src

// -- Constructors

fun StreamReadState(sys_stream src)
  StreamReadState("", false, src)

// -- Actions

act isValid(sys_stream s) -> bool
  intrinsic{stream_checkvalid}(s)

act flush(sys_stream s) -> Option{Error}
  intrinsic{stream_flush}(s)
    ? None()
    : Error("Failed to flush stream")

act setOptions(sys_stream s, StreamOptions opts) -> Option{Error}
  intrinsic{stream_setoptions}(s, int(opts))
    ? None()
    : Error("Failed to set stream options")

act unsetOptions(sys_stream s, StreamOptions opts) -> Option{Error}
  intrinsic{stream_unsetoptions}(s, int(opts))
    ? None()
    : Error("Failed to unset stream options")

// -- Reading actions

act read(sys_stream s, int maxChars) -> string
  intrinsic{stream_read_string}(s, maxChars)

act read(sys_stream s) -> char
  intrinsic{stream_read_char}(s)

act readToEnd(sys_stream s) -> string
  invoke(
    impure lambda (string result)
      read = s.read(512);
      if read.length() > 0  -> self(result + read)
      else                  -> result
    , "")

act readLine(sys_stream s) -> string
  invoke(
    impure lambda (string result)
      c = s.read();
      if c == '\r'              -> self(result)
      if c == '\n' || c == '\0' -> result
      else                      -> self(result + c)
  , "")

act readLine(StreamReadState state) -> Pair{string, StreamReadState}
  state.readUntil("\n" :: "\r\n")

act readUntil(StreamReadState state, List{string} patterns) -> Pair{string, StreamReadState}
  invoke(
    impure lambda (string txt)
      p = patterns.fold(  ( lambda (Pair{int, string} best, string p)
                              idx = txt.indexOf(p);
                              if idx < 0                            -> best
                              if best.first < 0 || idx < best.first -> Pair(idx, p)
                              else                                  -> best
                          ), Pair(-1, ""));
      idx = p.first;
      if idx >= 0 ->
        matchedTxt  = txt[0, idx];
        remTxt      = txt[idx + p.second.length(), txt.length()];
        Pair(matchedTxt, StreamReadState(remTxt, false, state.src))
      else        ->
        read = state.src.read(512);
        if read.isEmpty() -> Pair("", StreamReadState(txt, true, state.src))
        else              -> self(txt + read)
  , state.txt)

// -- Writing actions

act write(sys_stream s, string str) -> Option{Error}
  intrinsic{stream_write_string}(s, str)
    ? None()
    : Error("Failed to write to stream")

act write(sys_stream s, char c) -> Option{Error}
  intrinsic{stream_write_char}(s, c)
    ? None()
    : Error("Failed to write to stream")

act copy(sys_stream from, sys_stream to) -> Either{int, Error}
  invoke(
    impure lambda(int bytesCopied) -> Either{int, Error}
      read        = from.read(512);
      readLength  = read.length();
      if readLength > 0 -> to.write(read) as Error e ? e : self(bytesCopied + readLength)
      else              -> bytesCopied
  , 0).actIf(lazy to.flush())

act copyLines(sys_stream from, sys_stream to) -> Either{int, Error}
  invoke(impure lambda (StreamReadState state, int lines)
  (
    res = state.readLine();
    if res.second.reachedEnd  -> lines
    else                      ->
      actSeq(
        lazy to.write(res.first) ::
        lazy to.write('\n')      ::
        lazy to.flush()
       ) as Error e ? e : self(res.second, ++lines)
  ), StreamReadState(from), 0)
