import "pair.nov"
import "list.nov"
import "text.nov"

// -- Types

enum StreamOptions =
  NoBlock : 0b1

struct StreamReadState = string txt, bool reachedEnd, sys_stream src

// -- Constructors

fun StreamReadState(sys_stream src)
  StreamReadState("", false, src)

// -- Actions

act isValid(sys_stream s)
  s.streamCheckValid()

act setOptions(sys_stream s, StreamOptions opts)
  s.streamSetOptions(int(opts))

act unsetOptions(sys_stream s, StreamOptions opts)
  s.streamUnsetOptions(int(opts))

act write(sys_stream s, string str)
  s.streamWrite(str)

act write(sys_stream s, char c)
  s.streamWrite(c)

act readToEnd(sys_stream s)
  invoke(
    impure lambda (string result)
      read = s.streamRead(512);
      if read.length() > 0  -> self(result + read)
      else                  -> result
    , "")

act readChar(sys_stream s)
  s.streamRead()

act readLine(sys_stream s)
  invoke(
    impure lambda (string result)
      c = s.streamRead();
      if c == '\r'              -> self(result)
      if c == '\n' || c == '\0' -> result
      else                      -> self(result + c)
  , "")

act copy(sys_stream from, sys_stream to)
  bytesCopied = invoke(
    impure lambda(int bytesCopied)
      read        = from.streamRead(512);
      readLength  = read.length();
      if readLength > 0 -> to.streamWrite(read); self(bytesCopied + readLength)
      else              -> bytesCopied
  , 0);
  to.streamFlush(); bytesCopied

act copyLines(sys_stream from, sys_stream to)
  invoke(impure lambda (StreamReadState state, int lines)
  (
    res = state.readLine();
    if res.second.reachedEnd  -> lines
    else                      ->
      to.write(res.first);
      to.write('\n');
      to.streamFlush();
      self(res.second, ++lines)
  ), StreamReadState(from), 0)

act readLine(StreamReadState state)
  state.readUntil("\n" :: "\r\n")

act readUntil(StreamReadState state, List{string} patterns)
  invoke(
    impure lambda (string txt)
      p = patterns.fold(  ( lambda (Pair{int, string} best, string p)
                              idx = txt.indexOf(p);
                              if idx < 0                            -> best
                              if best.first < 0 || idx < best.first -> Pair(idx, p)
                              else                                  -> best
                          ), Pair(-1, ""));
      idx = p.first;
      if idx >= 0 ->
        matchedTxt  = txt[0, idx];
        remTxt      = txt[idx + p.second.length(), txt.length()];
        Pair(matchedTxt, StreamReadState(remTxt, false, state.src))
      else        ->
        read = state.src.streamRead(512);
        if read.isEmpty() -> Pair("", StreamReadState(txt, true, state.src))
        else              -> self(txt + read)
  , state.txt)
