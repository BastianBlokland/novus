import "std/pair.nov"
import "std/list.nov"
import "std/text.nov"

// -- Types

enum StreamOptions =
  NoBlock : 0b1

struct StreamReadState =
  string      txt,
  bool        reachedEnd,
  sys_stream  src

// -- Constructors

fun StreamReadState(sys_stream src)
  StreamReadState("", false, src)

// -- Actions

act setOptions(sys_stream s, StreamOptions opts) -> bool
  s.streamSetOptions(int(opts))

act unsetOptions(sys_stream s, StreamOptions opts) -> bool
  s.streamUnsetOptions(int(opts))

act write(sys_stream s, string str) -> bool
  s.streamWrite(str)

act write(sys_stream s, char c) -> bool
  s.streamWrite(c)

act readToEnd(sys_stream s) -> string
  invoke(
    impure lambda (string result)
      read = s.streamRead(512);
      if read.length() > 0  -> self(result + read)
      else                  -> result
    , "")

act readChar(sys_stream s) -> char
  s.streamRead()

act readLine(sys_stream s) -> string
  invoke(
    impure lambda (string result)
      c = s.streamRead();
      if c == '\r'              -> self(result)
      if c == '\n' || c == '\0' -> result
      else                      -> self(result + c)
  , "")

act copy(sys_stream from, sys_stream to) -> int
  bytesCopied = invoke(
    impure lambda(int bytesCopied)
      read        = from.streamRead(512);
      readLength  = read.length();
      if readLength > 0 -> to.streamWrite(read); self(bytesCopied + readLength)
      else              -> bytesCopied
  , 0);
  to.streamFlush(); bytesCopied

act copyLines(sys_stream from, sys_stream to) -> int
  invoke(impure lambda (StreamReadState state, int lines)
  (
    res = state.readLine();
    if res.second.reachedEnd  -> lines
    else                      ->
      to.write(res.first);
      to.write('\n');
      to.streamFlush();
      self(res.second, ++lines)
  ), StreamReadState(from), 0)

act readLine(StreamReadState state) -> Pair{string, StreamReadState}
  state.readUntil("\n" :: "\r\n")

act readUntil(StreamReadState state, List{string} patterns) -> Pair{string, StreamReadState}
  invoke(
    impure lambda (string txt)
      p = patterns.fold(  ( lambda (Pair{int, string} best, string p)
                              idx = txt.indexOf(p);
                              if idx < 0                            -> best
                              if best.first < 0 || idx < best.first -> Pair(idx, p)
                              else                                  -> best
                          ), Pair(-1, ""));
      idx = p.first;
      if idx >= 0 ->
        matchedTxt  = txt[0, idx];
        remTxt      = txt[idx + p.second.length(), txt.length()];
        Pair(matchedTxt, StreamReadState(remTxt, false, state.src))
      else        ->
        read = state.src.streamRead(512);
        if read.isEmpty() -> Pair("", StreamReadState(txt, true, state.src))
        else              -> self(txt + read)
  , state.txt)
