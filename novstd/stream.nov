import "std/lazy.nov"
import "std/list.nov"
import "std/pair.nov"
import "std/rt.nov"
import "std/text.nov"

// -- Types

enum StreamOptions =
  NoBlock : 0b1

struct StreamReadState =
  string      txt,
  bool        reachedEnd,
  sys_stream  src

// -- Constants

fun streamReadBlockSize() 1024

// -- Constructors

fun StreamReadState(sys_stream src)
  StreamReadState("", false, src)

// -- Actions

act isValid(sys_stream s) -> bool
  intrinsic{stream_checkvalid}(s)

act setOptions(sys_stream s, StreamOptions opts) -> Option{Error}
  intrinsic{stream_setoptions}(s, int(opts))
    ? None()
    : getPlatformError("Failed to set stream options")

act unsetOptions(sys_stream s, StreamOptions opts) -> Option{Error}
  intrinsic{stream_unsetoptions}(s, int(opts))
    ? None()
    : getPlatformError("Failed to unset stream options")

// -- Reading actions

act read(sys_stream s, int maxChars) -> Either{string, Error}
  res = intrinsic{stream_read_string}(s, maxChars);
  res.isEmpty() && getPlatformErrorCode() != PlatformError.StreamNoDataAvailable
    ? getPlatformError("Failed to read from stream")
    : res

act read(sys_stream s) -> Either{char, Error}
  res = intrinsic{stream_read_char}(s);
  res == '\0' && getPlatformErrorCode() != PlatformError.StreamNoDataAvailable
    ? getPlatformError("Failed to read from stream")
    : res

act readToEnd(sys_stream s) -> Either{string, Error}
  invoke(
    impure lambda (string result)
      readRes = s.read(streamReadBlockSize());
      if readRes as Error   e                         -> e
      if readRes as string  read && read.length() > 0 -> self(result + read)
      else                                            -> result
    , "")

act readLine(sys_stream s) -> Either{string, Error}
  invoke(
    impure lambda (string result)
      readRes = s.read();
      if readRes as Error e -> e
      if readRes as char  c ->
        if c == '\r'              -> self(result)
        if c == '\n' || c == '\0' -> result
        else                      -> self(result + c)
  , "")

act readLine(StreamReadState state) -> Either{Pair{string, StreamReadState}, Error}
  state.readUntil("\n" :: "\r\n")

act readUntil(StreamReadState state, List{string} patterns) -> Either{Pair{string, StreamReadState}, Error}
  invoke(
    impure lambda (string txt)
      p = patterns.fold(  ( lambda (Pair{int, string} best, string p)
                              idx = txt.indexOf(p);
                              if idx < 0                            -> best
                              if best.first < 0 || idx < best.first -> Pair(idx, p)
                              else                                  -> best
                          ), Pair(-1, ""));
      idx = p.first;
      if idx >= 0 ->
        matchedTxt  = txt[0, idx];
        remTxt      = txt[idx + p.second.length(), txt.length()];
        Pair(matchedTxt, StreamReadState(remTxt, false, state.src))
      else        ->
        readRes = state.src.read(streamReadBlockSize());
        if readRes as Error   e                           -> e
        if readRes as string  read && read.length() > 0   -> self(txt + read)
        else                                              -> Pair("", StreamReadState(txt, true, state.src))
  , state.txt)

// -- Writing actions

act write(sys_stream s, string str) -> Option{Error}
  intrinsic{stream_write_string}(s, str)
    ? None()
    : getPlatformError("Failed to write to stream")

act write(sys_stream s, char c) -> Option{Error}
  intrinsic{stream_write_char}(s, c)
    ? None()
    : getPlatformError("Failed to write to stream")

act copy(sys_stream from, sys_stream to) -> Either{int, Error}
  invoke(
    impure lambda(int bytesCopied) -> Either{int, Error}
      readRes     = from.read(streamReadBlockSize());
      if readRes as Error   readErr                   -> readErr
      if readRes as string  read && read.length() > 0 -> to.write(read) as Error writeErr
                                                          ? writeErr
                                                          : self(bytesCopied + read.length())
      else                                            -> bytesCopied
  , 0)
